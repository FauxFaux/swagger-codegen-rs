// generated by swagger-codegen-rs
use failure::Error;
use reqwest::Client;
use reqwest::header::Headers;
use reqwest::Url;

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Address {
    #[serde(rename = "Addr")]
    pub addr: String,
    #[serde(rename = "PrefixLen")]
    pub prefix_len: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthConfig {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "password")]
    pub password: String,
    #[serde(rename = "email")]
    pub email: String,
    #[serde(rename = "serveraddress")]
    pub serveraddress: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct BuildInfo {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "stream")]
    pub stream: String,
    #[serde(rename = "error")]
    pub error: String,
    #[serde(rename = "errorDetail")]
    pub error_detail: ErrorDetail,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "progress")]
    pub progress: String,
    #[serde(rename = "progressDetail")]
    pub progress_detail: ProgressDetail,
    #[serde(rename = "aux")]
    pub aux: ImageID,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct BuildPrune {
    #[serde(rename = "SpaceReclaimed")]
    pub space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ClusterInfo {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: SwarmSpec,
    #[serde(rename = "TLSInfo")]
    pub tls_info: TLSInfo,
    #[serde(rename = "RootRotationInProgress")]
    pub root_rotation_in_progress: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Commit {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Expected")]
    pub expected: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Config {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: ConfigSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ConfigSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Data")]
    pub data: String,
    #[serde(rename = "Templating")]
    pub templating: Driver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerChanges {
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Kind")]
    pub kind: u8,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerConfig {
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "Domainname")]
    pub domainname: String,
    #[serde(rename = "User")]
    pub user: String,
    #[serde(rename = "AttachStdin")]
    pub attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    pub attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    pub attach_stderr: bool,
    #[serde(rename = "ExposedPorts")]
    pub exposed_ports: ::serde_json::Value,
    #[serde(rename = "Tty")]
    pub tty: bool,
    #[serde(rename = "OpenStdin")]
    pub open_stdin: bool,
    #[serde(rename = "StdinOnce")]
    pub stdin_once: bool,
    #[serde(rename = "Env")]
    pub env: Vec<String>,
    #[serde(rename = "Cmd")]
    pub cmd: Vec<String>,
    #[serde(rename = "Healthcheck")]
    pub healthcheck: HealthConfig,
    #[serde(rename = "ArgsEscaped")]
    pub args_escaped: bool,
    #[serde(rename = "Image")]
    pub image: String,
    #[serde(rename = "Volumes")]
    pub volumes: ::serde_json::Value,
    #[serde(rename = "WorkingDir")]
    pub working_dir: String,
    #[serde(rename = "Entrypoint")]
    pub entrypoint: Vec<String>,
    #[serde(rename = "NetworkDisabled")]
    pub network_disabled: bool,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "OnBuild")]
    pub on_build: Vec<String>,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "StopSignal")]
    pub stop_signal: String,
    #[serde(rename = "StopTimeout")]
    pub stop_timeout: i64,
    #[serde(rename = "Shell")]
    pub shell: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateBody {
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "Domainname")]
    pub domainname: String,
    #[serde(rename = "User")]
    pub user: String,
    #[serde(rename = "AttachStdin")]
    pub attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    pub attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    pub attach_stderr: bool,
    #[serde(rename = "ExposedPorts")]
    pub exposed_ports: ::serde_json::Value,
    #[serde(rename = "Tty")]
    pub tty: bool,
    #[serde(rename = "OpenStdin")]
    pub open_stdin: bool,
    #[serde(rename = "StdinOnce")]
    pub stdin_once: bool,
    #[serde(rename = "Env")]
    pub env: Vec<String>,
    #[serde(rename = "Cmd")]
    pub cmd: Vec<String>,
    #[serde(rename = "Healthcheck")]
    pub healthcheck: HealthConfig,
    #[serde(rename = "ArgsEscaped")]
    pub args_escaped: bool,
    #[serde(rename = "Image")]
    pub image: String,
    #[serde(rename = "Volumes")]
    pub volumes: ::serde_json::Value,
    #[serde(rename = "WorkingDir")]
    pub working_dir: String,
    #[serde(rename = "Entrypoint")]
    pub entrypoint: Vec<String>,
    #[serde(rename = "NetworkDisabled")]
    pub network_disabled: bool,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "OnBuild")]
    pub on_build: Vec<String>,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "StopSignal")]
    pub stop_signal: String,
    #[serde(rename = "StopTimeout")]
    pub stop_timeout: i64,
    #[serde(rename = "Shell")]
    pub shell: Vec<String>,
    #[serde(rename = "HostConfig")]
    pub host_config: HostConfig,
    #[serde(rename = "NetworkingConfig")]
    pub networking_config: ContainerCreateNetworkingConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateCreated {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateHostConfigBlkioWeightDevice {
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Weight")]
    pub weight: u64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerCreateHostConfigIsolation {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "process")]
    Process,
    #[serde(rename = "hyperv")]
    Hyperv,
}

impl ToString for ContainerCreateHostConfigIsolation {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigIsolation::Default => "default",
            ContainerCreateHostConfigIsolation::Process => "process",
            ContainerCreateHostConfigIsolation::Hyperv => "hyperv",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateHostConfigLogConfig {
    #[serde(rename = "Type")]
    pub type_: ContainerCreateHostConfigLogConfigType,
    #[serde(rename = "Config")]
    pub config: ::serde_json::Value,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerCreateHostConfigLogConfigType {
    #[serde(rename = "json-file")]
    Jsonfile,
    #[serde(rename = "syslog")]
    Syslog,
    #[serde(rename = "journald")]
    Journald,
    #[serde(rename = "gelf")]
    Gelf,
    #[serde(rename = "fluentd")]
    Fluentd,
    #[serde(rename = "awslogs")]
    Awslogs,
    #[serde(rename = "splunk")]
    Splunk,
    #[serde(rename = "etwlogs")]
    Etwlogs,
    #[serde(rename = "none")]
    None,
}

impl ToString for ContainerCreateHostConfigLogConfigType {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigLogConfigType::Jsonfile => "json-file",
            ContainerCreateHostConfigLogConfigType::Syslog => "syslog",
            ContainerCreateHostConfigLogConfigType::Journald => "journald",
            ContainerCreateHostConfigLogConfigType::Gelf => "gelf",
            ContainerCreateHostConfigLogConfigType::Fluentd => "fluentd",
            ContainerCreateHostConfigLogConfigType::Awslogs => "awslogs",
            ContainerCreateHostConfigLogConfigType::Splunk => "splunk",
            ContainerCreateHostConfigLogConfigType::Etwlogs => "etwlogs",
            ContainerCreateHostConfigLogConfigType::None => "none",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerCreateHostConfigRestartPolicyName {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "always")]
    Always,
    #[serde(rename = "unless-stopped")]
    Unlessstopped,
    #[serde(rename = "on-failure")]
    Onfailure,
}

impl ToString for ContainerCreateHostConfigRestartPolicyName {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigRestartPolicyName::Empty => "",
            ContainerCreateHostConfigRestartPolicyName::Always => "always",
            ContainerCreateHostConfigRestartPolicyName::Unlessstopped => "unless-stopped",
            ContainerCreateHostConfigRestartPolicyName::Onfailure => "on-failure",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateHostConfigUlimits {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Soft")]
    pub soft: i64,
    #[serde(rename = "Hard")]
    pub hard: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerCreateNetworkingConfig {
    #[serde(rename = "EndpointsConfig")]
    pub endpoints_config: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerExec {
    #[serde(rename = "AttachStdin")]
    pub attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    pub attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    pub attach_stderr: bool,
    #[serde(rename = "DetachKeys")]
    pub detach_keys: String,
    #[serde(rename = "Tty")]
    pub tty: bool,
    #[serde(rename = "Env")]
    pub env: Vec<String>,
    #[serde(rename = "Cmd")]
    pub cmd: Vec<String>,
    #[serde(rename = "Privileged")]
    pub privileged: bool,
    #[serde(rename = "User")]
    pub user: String,
    #[serde(rename = "WorkingDir")]
    pub working_dir: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerInspect {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Created")]
    pub created: String,
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Args")]
    pub args: Vec<String>,
    #[serde(rename = "State")]
    pub state: ContainerInspectState,
    #[serde(rename = "Image")]
    pub image: String,
    #[serde(rename = "ResolvConfPath")]
    pub resolv_conf_path: String,
    #[serde(rename = "HostnamePath")]
    pub hostname_path: String,
    #[serde(rename = "HostsPath")]
    pub hosts_path: String,
    #[serde(rename = "LogPath")]
    pub log_path: String,
    #[serde(rename = "Node")]
    pub node: ::serde_json::Value,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "RestartCount")]
    pub restart_count: i64,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "MountLabel")]
    pub mount_label: String,
    #[serde(rename = "ProcessLabel")]
    pub process_label: String,
    #[serde(rename = "AppArmorProfile")]
    pub app_armor_profile: String,
    #[serde(rename = "ExecIDs")]
    pub exec_i_ds: Vec<String>,
    #[serde(rename = "HostConfig")]
    pub host_config: HostConfig,
    #[serde(rename = "GraphDriver")]
    pub graph_driver: GraphDriverData,
    #[serde(rename = "SizeRw")]
    pub size_rw: i64,
    #[serde(rename = "SizeRootFs")]
    pub size_root_fs: i64,
    #[serde(rename = "Mounts")]
    pub mounts: Vec<MountPoint>,
    #[serde(rename = "Config")]
    pub config: ContainerConfig,
    #[serde(rename = "NetworkSettings")]
    pub network_settings: NetworkSettings,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerInspectState {
    #[serde(rename = "Status")]
    pub status: ContainerInspectStateStatus,
    #[serde(rename = "Running")]
    pub running: bool,
    #[serde(rename = "Paused")]
    pub paused: bool,
    #[serde(rename = "Restarting")]
    pub restarting: bool,
    #[serde(rename = "OOMKilled")]
    pub oom_killed: bool,
    #[serde(rename = "Dead")]
    pub dead: bool,
    #[serde(rename = "Pid")]
    pub pid: i64,
    #[serde(rename = "ExitCode")]
    pub exit_code: i64,
    #[serde(rename = "Error")]
    pub error: String,
    #[serde(rename = "StartedAt")]
    pub started_at: String,
    #[serde(rename = "FinishedAt")]
    pub finished_at: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerInspectStateStatus {
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "paused")]
    Paused,
    #[serde(rename = "restarting")]
    Restarting,
    #[serde(rename = "removing")]
    Removing,
    #[serde(rename = "exited")]
    Exited,
    #[serde(rename = "dead")]
    Dead,
}

impl ToString for ContainerInspectStateStatus {
    fn to_string(&self) -> String {
        match self {
            ContainerInspectStateStatus::Created => "created",
            ContainerInspectStateStatus::Running => "running",
            ContainerInspectStateStatus::Paused => "paused",
            ContainerInspectStateStatus::Restarting => "restarting",
            ContainerInspectStateStatus::Removing => "removing",
            ContainerInspectStateStatus::Exited => "exited",
            ContainerInspectStateStatus::Dead => "dead",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerList {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Names")]
    pub names: Vec<String>,
    #[serde(rename = "Image")]
    pub image: String,
    #[serde(rename = "ImageID")]
    pub image_id: String,
    #[serde(rename = "Command")]
    pub command: String,
    #[serde(rename = "Created")]
    pub created: i64,
    #[serde(rename = "Ports")]
    pub ports: Vec<Port>,
    #[serde(rename = "SizeRw")]
    pub size_rw: i64,
    #[serde(rename = "SizeRootFs")]
    pub size_root_fs: i64,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "State")]
    pub state: String,
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "HostConfig")]
    pub host_config: ContainerListHostConfig,
    #[serde(rename = "NetworkSettings")]
    pub network_settings: ContainerListNetworkSettings,
    #[serde(rename = "Mounts")]
    pub mounts: Vec<Mount>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListHostConfig {
    #[serde(rename = "NetworkMode")]
    pub network_mode: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListMountsBindOptions {
    #[serde(rename = "Propagation")]
    pub propagation: ContainerListMountsBindOptionsPropagation,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerListMountsBindOptionsPropagation {
    #[serde(rename = "private")]
    Private,
    #[serde(rename = "rprivate")]
    Rprivate,
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "rshared")]
    Rshared,
    #[serde(rename = "slave")]
    Slave,
    #[serde(rename = "rslave")]
    Rslave,
}

impl ToString for ContainerListMountsBindOptionsPropagation {
    fn to_string(&self) -> String {
        match self {
            ContainerListMountsBindOptionsPropagation::Private => "private",
            ContainerListMountsBindOptionsPropagation::Rprivate => "rprivate",
            ContainerListMountsBindOptionsPropagation::Shared => "shared",
            ContainerListMountsBindOptionsPropagation::Rshared => "rshared",
            ContainerListMountsBindOptionsPropagation::Slave => "slave",
            ContainerListMountsBindOptionsPropagation::Rslave => "rslave",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListMountsTmpfsOptions {
    #[serde(rename = "SizeBytes")]
    pub size_bytes: i64,
    #[serde(rename = "Mode")]
    pub mode: i64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerListMountsType {
    #[serde(rename = "bind")]
    Bind,
    #[serde(rename = "volume")]
    Volume,
    #[serde(rename = "tmpfs")]
    Tmpfs,
}

impl ToString for ContainerListMountsType {
    fn to_string(&self) -> String {
        match self {
            ContainerListMountsType::Bind => "bind",
            ContainerListMountsType::Volume => "volume",
            ContainerListMountsType::Tmpfs => "tmpfs",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListMountsVolumeOptions {
    #[serde(rename = "NoCopy")]
    pub no_copy: bool,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "DriverConfig")]
    pub driver_config: ContainerListMountsVolumeOptionsDriverConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListMountsVolumeOptionsDriverConfig {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerListNetworkSettings {
    #[serde(rename = "Networks")]
    pub networks: ::serde_json::Value,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ContainerListPortsType {
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
    #[serde(rename = "sctp")]
    Sctp,
}

impl ToString for ContainerListPortsType {
    fn to_string(&self) -> String {
        match self {
            ContainerListPortsType::Tcp => "tcp",
            ContainerListPortsType::Udp => "udp",
            ContainerListPortsType::Sctp => "sctp",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerPrune {
    #[serde(rename = "ContainersDeleted")]
    pub containers_deleted: Vec<String>,
    #[serde(rename = "SpaceReclaimed")]
    pub space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerTop {
    #[serde(rename = "Titles")]
    pub titles: Vec<String>,
    #[serde(rename = "Processes")]
    pub processes: Vec<Vec<String>>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerUpdateOk {
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerUpdateUpdate {
    #[serde(rename = "CpuShares")]
    pub cpu_shares: i64,
    #[serde(rename = "Memory")]
    pub memory: i64,
    #[serde(rename = "CgroupParent")]
    pub cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    pub blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    pub blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    pub blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    pub blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    pub blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    pub blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    pub cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    pub cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    pub cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    pub cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    pub cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    pub cpuset_mems: String,
    #[serde(rename = "Devices")]
    pub devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    pub device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    pub disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    pub kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    pub memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    pub memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    pub memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    pub nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    pub oom_kill_disable: bool,
    #[serde(rename = "Init")]
    pub init: bool,
    #[serde(rename = "PidsLimit")]
    pub pids_limit: i64,
    #[serde(rename = "Ulimits")]
    pub ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    pub cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    pub cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    pub io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    pub io_maximum_bandwidth: i64,
    #[serde(rename = "RestartPolicy")]
    pub restart_policy: RestartPolicy,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerWait {
    #[serde(rename = "StatusCode")]
    pub status_code: i64,
    #[serde(rename = "Error")]
    pub error: ContainerWaitError,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerWaitError {
    #[serde(rename = "Message")]
    pub message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateImageInfo {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "error")]
    pub error: String,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "progress")]
    pub progress: String,
    #[serde(rename = "progressDetail")]
    pub progress_detail: ProgressDetail,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct DeviceMapping {
    #[serde(rename = "PathOnHost")]
    pub path_on_host: String,
    #[serde(rename = "PathInContainer")]
    pub path_in_container: String,
    #[serde(rename = "CgroupPermissions")]
    pub cgroup_permissions: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct DistributionInspect {
    #[serde(rename = "Descriptor")]
    pub descriptor: DistributionInspectDescriptor,
    #[serde(rename = "Platforms")]
    pub platforms: Vec<DistributionInspectPlatforms>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct DistributionInspectDescriptor {
    #[serde(rename = "MediaType")]
    pub media_type: String,
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "Digest")]
    pub digest: String,
    #[serde(rename = "URLs")]
    pub ur_ls: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct DistributionInspectPlatforms {
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "OS")]
    pub os: String,
    #[serde(rename = "OSVersion")]
    pub os_version: String,
    #[serde(rename = "OSFeatures")]
    pub os_features: Vec<String>,
    #[serde(rename = "Variant")]
    pub variant: String,
    #[serde(rename = "Features")]
    pub features: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Driver {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct EndpointIPAMConfig {
    #[serde(rename = "IPv4Address")]
    pub i_pv4_address: String,
    #[serde(rename = "IPv6Address")]
    pub i_pv6_address: String,
    #[serde(rename = "LinkLocalIPs")]
    pub link_local_i_ps: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct EndpointPortConfig {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Protocol")]
    pub protocol: ContainerListPortsType,
    #[serde(rename = "TargetPort")]
    pub target_port: i64,
    #[serde(rename = "PublishedPort")]
    pub published_port: i64,
    #[serde(rename = "PublishMode")]
    pub publish_mode: ServiceListSpecEndpointSpecPortsPublishMode,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct EndpointSettings {
    #[serde(rename = "IPAMConfig")]
    pub ipam_config: EndpointIPAMConfig,
    #[serde(rename = "Links")]
    pub links: Vec<String>,
    #[serde(rename = "Aliases")]
    pub aliases: Vec<String>,
    #[serde(rename = "NetworkID")]
    pub network_id: String,
    #[serde(rename = "EndpointID")]
    pub endpoint_id: String,
    #[serde(rename = "Gateway")]
    pub gateway: String,
    #[serde(rename = "IPAddress")]
    pub ip_address: String,
    #[serde(rename = "IPPrefixLen")]
    pub ip_prefix_len: i64,
    #[serde(rename = "IPv6Gateway")]
    pub i_pv6_gateway: String,
    #[serde(rename = "GlobalIPv6Address")]
    pub global_i_pv6_address: String,
    #[serde(rename = "GlobalIPv6PrefixLen")]
    pub global_i_pv6_prefix_len: i64,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "DriverOpts")]
    pub driver_opts: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct EndpointSpec {
    #[serde(rename = "Mode")]
    pub mode: ServiceListSpecEndpointSpecMode,
    #[serde(rename = "Ports")]
    pub ports: Vec<EndpointPortConfig>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct EngineDescription {
    #[serde(rename = "EngineVersion")]
    pub engine_version: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Plugins")]
    pub plugins: Vec<NodeListDescriptionEnginePlugins>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ErrorDetail {
    #[serde(rename = "code")]
    pub code: i64,
    #[serde(rename = "message")]
    pub message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ErrorResponse {
    #[serde(rename = "message")]
    pub message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ExecInspect {
    #[serde(rename = "CanRemove")]
    pub can_remove: bool,
    #[serde(rename = "DetachKeys")]
    pub detach_keys: String,
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Running")]
    pub running: bool,
    #[serde(rename = "ExitCode")]
    pub exit_code: i64,
    #[serde(rename = "ProcessConfig")]
    pub process_config: ProcessConfig,
    #[serde(rename = "OpenStdin")]
    pub open_stdin: bool,
    #[serde(rename = "OpenStderr")]
    pub open_stderr: bool,
    #[serde(rename = "OpenStdout")]
    pub open_stdout: bool,
    #[serde(rename = "ContainerID")]
    pub container_id: String,
    #[serde(rename = "Pid")]
    pub pid: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ExecStart {
    #[serde(rename = "Detach")]
    pub detach: bool,
    #[serde(rename = "Tty")]
    pub tty: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct GetPluginPrivileges {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct GraphDriverData {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Data")]
    pub data: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct HealthConfig {
    #[serde(rename = "Test")]
    pub test: Vec<String>,
    #[serde(rename = "Interval")]
    pub interval: i64,
    #[serde(rename = "Timeout")]
    pub timeout: i64,
    #[serde(rename = "Retries")]
    pub retries: i64,
    #[serde(rename = "StartPeriod")]
    pub start_period: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct HostConfig {
    #[serde(rename = "CpuShares")]
    pub cpu_shares: i64,
    #[serde(rename = "Memory")]
    pub memory: i64,
    #[serde(rename = "CgroupParent")]
    pub cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    pub blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    pub blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    pub blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    pub blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    pub blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    pub blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    pub cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    pub cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    pub cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    pub cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    pub cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    pub cpuset_mems: String,
    #[serde(rename = "Devices")]
    pub devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    pub device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    pub disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    pub kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    pub memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    pub memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    pub memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    pub nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    pub oom_kill_disable: bool,
    #[serde(rename = "Init")]
    pub init: bool,
    #[serde(rename = "PidsLimit")]
    pub pids_limit: i64,
    #[serde(rename = "Ulimits")]
    pub ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    pub cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    pub cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    pub io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    pub io_maximum_bandwidth: i64,
    #[serde(rename = "Binds")]
    pub binds: Vec<String>,
    #[serde(rename = "ContainerIDFile")]
    pub container_id_file: String,
    #[serde(rename = "LogConfig")]
    pub log_config: ContainerCreateHostConfigLogConfig,
    #[serde(rename = "NetworkMode")]
    pub network_mode: String,
    #[serde(rename = "PortBindings")]
    pub port_bindings: ::serde_json::Value,
    #[serde(rename = "RestartPolicy")]
    pub restart_policy: RestartPolicy,
    #[serde(rename = "AutoRemove")]
    pub auto_remove: bool,
    #[serde(rename = "VolumeDriver")]
    pub volume_driver: String,
    #[serde(rename = "VolumesFrom")]
    pub volumes_from: Vec<String>,
    #[serde(rename = "Mounts")]
    pub mounts: Vec<Mount>,
    #[serde(rename = "CapAdd")]
    pub cap_add: Vec<String>,
    #[serde(rename = "CapDrop")]
    pub cap_drop: Vec<String>,
    #[serde(rename = "Dns")]
    pub dns: Vec<String>,
    #[serde(rename = "DnsOptions")]
    pub dns_options: Vec<String>,
    #[serde(rename = "DnsSearch")]
    pub dns_search: Vec<String>,
    #[serde(rename = "ExtraHosts")]
    pub extra_hosts: Vec<String>,
    #[serde(rename = "GroupAdd")]
    pub group_add: Vec<String>,
    #[serde(rename = "IpcMode")]
    pub ipc_mode: String,
    #[serde(rename = "Cgroup")]
    pub cgroup: String,
    #[serde(rename = "Links")]
    pub links: Vec<String>,
    #[serde(rename = "OomScoreAdj")]
    pub oom_score_adj: i64,
    #[serde(rename = "PidMode")]
    pub pid_mode: String,
    #[serde(rename = "Privileged")]
    pub privileged: bool,
    #[serde(rename = "PublishAllPorts")]
    pub publish_all_ports: bool,
    #[serde(rename = "ReadonlyRootfs")]
    pub readonly_rootfs: bool,
    #[serde(rename = "SecurityOpt")]
    pub security_opt: Vec<String>,
    #[serde(rename = "StorageOpt")]
    pub storage_opt: ::serde_json::Value,
    #[serde(rename = "Tmpfs")]
    pub tmpfs: ::serde_json::Value,
    #[serde(rename = "UTSMode")]
    pub uts_mode: String,
    #[serde(rename = "UsernsMode")]
    pub userns_mode: String,
    #[serde(rename = "ShmSize")]
    pub shm_size: u64,
    #[serde(rename = "Sysctls")]
    pub sysctls: ::serde_json::Value,
    #[serde(rename = "Runtime")]
    pub runtime: String,
    #[serde(rename = "ConsoleSize")]
    pub console_size: Vec<u64>,
    #[serde(rename = "Isolation")]
    pub isolation: ContainerCreateHostConfigIsolation,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct IPAM {
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "Config")]
    pub config: Vec<::serde_json::Value>,
    #[serde(rename = "Options")]
    pub options: Vec<::serde_json::Value>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct IdResponse {
    #[serde(rename = "Id")]
    pub id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Image {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "RepoTags")]
    pub repo_tags: Vec<String>,
    #[serde(rename = "RepoDigests")]
    pub repo_digests: Vec<String>,
    #[serde(rename = "Parent")]
    pub parent: String,
    #[serde(rename = "Comment")]
    pub comment: String,
    #[serde(rename = "Created")]
    pub created: String,
    #[serde(rename = "Container")]
    pub container: String,
    #[serde(rename = "ContainerConfig")]
    pub container_config: ContainerConfig,
    #[serde(rename = "DockerVersion")]
    pub docker_version: String,
    #[serde(rename = "Author")]
    pub author: String,
    #[serde(rename = "Config")]
    pub config: ContainerConfig,
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "Os")]
    pub os: String,
    #[serde(rename = "OsVersion")]
    pub os_version: String,
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "VirtualSize")]
    pub virtual_size: i64,
    #[serde(rename = "GraphDriver")]
    pub graph_driver: GraphDriverData,
    #[serde(rename = "RootFS")]
    pub root_fs: ImageInspectRootFS,
    #[serde(rename = "Metadata")]
    pub metadata: ImageInspectMetadata,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ImageBuild {
    #[serde(rename = "application/x-tar")]
    Applicationxtar,
}

impl Default for ImageBuild {
    fn default() -> Self {
        ImageBuild::Applicationxtar
    }
}

impl ToString for ImageBuild {
    fn to_string(&self) -> String {
        match self {
            ImageBuild::Applicationxtar => "application/x-tar",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageDeleteResponseItem {
    #[serde(rename = "Untagged")]
    pub untagged: String,
    #[serde(rename = "Deleted")]
    pub deleted: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageHistory {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Created")]
    pub created: i64,
    #[serde(rename = "CreatedBy")]
    pub created_by: String,
    #[serde(rename = "Tags")]
    pub tags: Vec<String>,
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "Comment")]
    pub comment: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageID {
    #[serde(rename = "ID")]
    pub id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageInspectMetadata {
    #[serde(rename = "LastTagTime")]
    pub last_tag_time: ::chrono::DateTime<::chrono::Utc>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageInspectRootFS {
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Layers")]
    pub layers: Vec<String>,
    #[serde(rename = "BaseLayer")]
    pub base_layer: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImagePrune {
    #[serde(rename = "ImagesDeleted")]
    pub images_deleted: Vec<ImageDeleteResponseItem>,
    #[serde(rename = "SpaceReclaimed")]
    pub space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageSearch {
    #[serde(rename = "description")]
    pub description: String,
    #[serde(rename = "is_official")]
    pub is_official: bool,
    #[serde(rename = "is_automated")]
    pub is_automated: bool,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "star_count")]
    pub star_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageSummary {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "ParentId")]
    pub parent_id: String,
    #[serde(rename = "RepoTags")]
    pub repo_tags: Vec<String>,
    #[serde(rename = "RepoDigests")]
    pub repo_digests: Vec<String>,
    #[serde(rename = "Created")]
    pub created: i64,
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "SharedSize")]
    pub shared_size: i64,
    #[serde(rename = "VirtualSize")]
    pub virtual_size: i64,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Containers")]
    pub containers: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct IndexInfo {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Mirrors")]
    pub mirrors: Vec<String>,
    #[serde(rename = "Secure")]
    pub secure: bool,
    #[serde(rename = "Official")]
    pub official: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct JoinTokens {
    #[serde(rename = "Worker")]
    pub worker: String,
    #[serde(rename = "Manager")]
    pub manager: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum LocalNodeState {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "inactive")]
    Inactive,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "locked")]
    Locked,
}

impl Default for LocalNodeState {
    fn default() -> Self {
        LocalNodeState::Empty
    }
}

impl ToString for LocalNodeState {
    fn to_string(&self) -> String {
        match self {
            LocalNodeState::Empty => "",
            LocalNodeState::Inactive => "inactive",
            LocalNodeState::Pending => "pending",
            LocalNodeState::Active => "active",
            LocalNodeState::Error => "error",
            LocalNodeState::Locked => "locked",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ManagerStatus {
    #[serde(rename = "Leader")]
    pub leader: bool,
    #[serde(rename = "Reachability")]
    pub reachability: Reachability,
    #[serde(rename = "Addr")]
    pub addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Mount {
    #[serde(rename = "Target")]
    pub target: String,
    #[serde(rename = "Source")]
    pub source: String,
    #[serde(rename = "Type")]
    pub type_: ContainerListMountsType,
    #[serde(rename = "ReadOnly")]
    pub read_only: bool,
    #[serde(rename = "Consistency")]
    pub consistency: String,
    #[serde(rename = "BindOptions")]
    pub bind_options: ContainerListMountsBindOptions,
    #[serde(rename = "VolumeOptions")]
    pub volume_options: ContainerListMountsVolumeOptions,
    #[serde(rename = "TmpfsOptions")]
    pub tmpfs_options: ContainerListMountsTmpfsOptions,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct MountPoint {
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Source")]
    pub source: String,
    #[serde(rename = "Destination")]
    pub destination: String,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "Mode")]
    pub mode: String,
    #[serde(rename = "RW")]
    pub rw: bool,
    #[serde(rename = "Propagation")]
    pub propagation: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Network {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Created")]
    pub created: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Scope")]
    pub scope: String,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "EnableIPv6")]
    pub enable_i_pv6: bool,
    #[serde(rename = "IPAM")]
    pub ipam: IPAM,
    #[serde(rename = "Internal")]
    pub internal: bool,
    #[serde(rename = "Attachable")]
    pub attachable: bool,
    #[serde(rename = "Ingress")]
    pub ingress: bool,
    #[serde(rename = "Containers")]
    pub containers: ::serde_json::Value,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkConnect {
    #[serde(rename = "Container")]
    pub container: String,
    #[serde(rename = "EndpointConfig")]
    pub endpoint_config: EndpointSettings,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkContainer {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "EndpointID")]
    pub endpoint_id: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "IPv4Address")]
    pub i_pv4_address: String,
    #[serde(rename = "IPv6Address")]
    pub i_pv6_address: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkCreateCreated {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Warning")]
    pub warning: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkCreateNetworkConfig {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "CheckDuplicate")]
    pub check_duplicate: bool,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "Internal")]
    pub internal: bool,
    #[serde(rename = "Attachable")]
    pub attachable: bool,
    #[serde(rename = "Ingress")]
    pub ingress: bool,
    #[serde(rename = "IPAM")]
    pub ipam: IPAM,
    #[serde(rename = "EnableIPv6")]
    pub enable_i_pv6: bool,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkDisconnect {
    #[serde(rename = "Container")]
    pub container: String,
    #[serde(rename = "Force")]
    pub force: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkPrune {
    #[serde(rename = "NetworksDeleted")]
    pub networks_deleted: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettings {
    #[serde(rename = "Bridge")]
    pub bridge: String,
    #[serde(rename = "SandboxID")]
    pub sandbox_id: String,
    #[serde(rename = "HairpinMode")]
    pub hairpin_mode: bool,
    #[serde(rename = "LinkLocalIPv6Address")]
    pub link_local_i_pv6_address: String,
    #[serde(rename = "LinkLocalIPv6PrefixLen")]
    pub link_local_i_pv6_prefix_len: i64,
    #[serde(rename = "Ports")]
    pub ports: ::serde_json::Value,
    #[serde(rename = "SandboxKey")]
    pub sandbox_key: String,
    #[serde(rename = "SecondaryIPAddresses")]
    pub secondary_ip_addresses: Vec<Address>,
    #[serde(rename = "SecondaryIPv6Addresses")]
    pub secondary_i_pv6_addresses: Vec<Address>,
    #[serde(rename = "EndpointID")]
    pub endpoint_id: String,
    #[serde(rename = "Gateway")]
    pub gateway: String,
    #[serde(rename = "GlobalIPv6Address")]
    pub global_i_pv6_address: String,
    #[serde(rename = "GlobalIPv6PrefixLen")]
    pub global_i_pv6_prefix_len: i64,
    #[serde(rename = "IPAddress")]
    pub ip_address: String,
    #[serde(rename = "IPPrefixLen")]
    pub ip_prefix_len: i64,
    #[serde(rename = "IPv6Gateway")]
    pub i_pv6_gateway: String,
    #[serde(rename = "MacAddress")]
    pub mac_address: String,
    #[serde(rename = "Networks")]
    pub networks: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Node {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: NodeSpec,
    #[serde(rename = "Description")]
    pub description: NodeDescription,
    #[serde(rename = "Status")]
    pub status: NodeStatus,
    #[serde(rename = "ManagerStatus")]
    pub manager_status: ManagerStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NodeDescription {
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "Platform")]
    pub platform: Platform,
    #[serde(rename = "Resources")]
    pub resources: ResourceObject,
    #[serde(rename = "Engine")]
    pub engine: EngineDescription,
    #[serde(rename = "TLSInfo")]
    pub tls_info: TLSInfo,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NodeListDescriptionEnginePlugins {
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Name")]
    pub name: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum NodeListSpecAvailability {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "pause")]
    Pause,
    #[serde(rename = "drain")]
    Drain,
}

impl ToString for NodeListSpecAvailability {
    fn to_string(&self) -> String {
        match self {
            NodeListSpecAvailability::Active => "active",
            NodeListSpecAvailability::Pause => "pause",
            NodeListSpecAvailability::Drain => "drain",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum NodeListSpecRole {
    #[serde(rename = "worker")]
    Worker,
    #[serde(rename = "manager")]
    Manager,
}

impl ToString for NodeListSpecRole {
    fn to_string(&self) -> String {
        match self {
            NodeListSpecRole::Worker => "worker",
            NodeListSpecRole::Manager => "manager",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NodeSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Role")]
    pub role: NodeListSpecRole,
    #[serde(rename = "Availability")]
    pub availability: NodeListSpecAvailability,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum NodeState {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "down")]
    Down,
    #[serde(rename = "ready")]
    Ready,
    #[serde(rename = "disconnected")]
    Disconnected,
}

impl ToString for NodeState {
    fn to_string(&self) -> String {
        match self {
            NodeState::Unknown => "unknown",
            NodeState::Down => "down",
            NodeState::Ready => "ready",
            NodeState::Disconnected => "disconnected",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct NodeStatus {
    #[serde(rename = "State")]
    pub state: NodeState,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "Addr")]
    pub addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ObjectVersion {
    #[serde(rename = "Inde")]
    pub inde: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PeerNode {
    #[serde(rename = "NodeID")]
    pub node_id: String,
    #[serde(rename = "Addr")]
    pub addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Platform {
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "OS")]
    pub os: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Plugin {
    #[serde(rename = "Id")]
    pub id: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Enabled")]
    pub enabled: bool,
    #[serde(rename = "Settings")]
    pub settings: PluginListSettings,
    #[serde(rename = "PluginReference")]
    pub plugin_reference: String,
    #[serde(rename = "Config")]
    pub config: PluginListConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginDevice {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,
    #[serde(rename = "Path")]
    pub path: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginEnv {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,
    #[serde(rename = "Value")]
    pub value: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginInterfaceType {
    #[serde(rename = "Prefix")]
    pub prefix: String,
    #[serde(rename = "Capability")]
    pub capability: String,
    #[serde(rename = "Version")]
    pub version: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfig {
    #[serde(rename = "DockerVersion")]
    pub docker_version: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Documentation")]
    pub documentation: String,
    #[serde(rename = "Interface")]
    pub interface: PluginListConfigInterface,
    #[serde(rename = "Entrypoint")]
    pub entrypoint: Vec<String>,
    #[serde(rename = "WorkDir")]
    pub work_dir: String,
    #[serde(rename = "User")]
    pub user: PluginListConfigUser,
    #[serde(rename = "Network")]
    pub network: PluginListConfigNetwork,
    #[serde(rename = "Linux")]
    pub linux: PluginListConfigLinux,
    #[serde(rename = "PropagatedMount")]
    pub propagated_mount: String,
    #[serde(rename = "IpcHost")]
    pub ipc_host: bool,
    #[serde(rename = "PidHost")]
    pub pid_host: bool,
    #[serde(rename = "Mounts")]
    pub mounts: Vec<PluginMount>,
    #[serde(rename = "Env")]
    pub env: Vec<PluginEnv>,
    #[serde(rename = "Args")]
    pub args: PluginListConfigArgs,
    #[serde(rename = "rootfs")]
    pub rootfs: PluginListConfigrootfs,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigArgs {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,
    #[serde(rename = "Value")]
    pub value: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigInterface {
    #[serde(rename = "Types")]
    pub types: Vec<PluginInterfaceType>,
    #[serde(rename = "Socket")]
    pub socket: String,
    #[serde(rename = "ProtocolScheme")]
    pub protocol_scheme: PluginListConfigInterfaceProtocolScheme,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PluginListConfigInterfaceProtocolScheme {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "moby.plugins.http/v1")]
    Mobypluginshttpv1,
}

impl ToString for PluginListConfigInterfaceProtocolScheme {
    fn to_string(&self) -> String {
        match self {
            PluginListConfigInterfaceProtocolScheme::Empty => "",
            PluginListConfigInterfaceProtocolScheme::Mobypluginshttpv1 => "moby.plugins.http/v1",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigLinux {
    #[serde(rename = "Capabilities")]
    pub capabilities: Vec<String>,
    #[serde(rename = "AllowAllDevices")]
    pub allow_all_devices: bool,
    #[serde(rename = "Devices")]
    pub devices: Vec<PluginDevice>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigNetwork {
    #[serde(rename = "Type")]
    pub type_: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigUser {
    #[serde(rename = "UID")]
    pub uid: u32,
    #[serde(rename = "GID")]
    pub gid: u32,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListConfigrootfs {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "diff_ids")]
    pub diff_ids: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginListSettings {
    #[serde(rename = "Mounts")]
    pub mounts: Vec<PluginMount>,
    #[serde(rename = "Env")]
    pub env: Vec<String>,
    #[serde(rename = "Args")]
    pub args: Vec<String>,
    #[serde(rename = "Devices")]
    pub devices: Vec<PluginDevice>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginMount {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Description")]
    pub description: String,
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,
    #[serde(rename = "Source")]
    pub source: String,
    #[serde(rename = "Destination")]
    pub destination: String,
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Options")]
    pub options: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PluginsInfo {
    #[serde(rename = "Volume")]
    pub volume: Vec<String>,
    #[serde(rename = "Network")]
    pub network: Vec<String>,
    #[serde(rename = "Authorization")]
    pub authorization: Vec<String>,
    #[serde(rename = "Log")]
    pub log: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Port {
    #[serde(rename = "IP")]
    pub ip: ::std::net::IpAddr,
    #[serde(rename = "PrivatePort")]
    pub private_port: u16,
    #[serde(rename = "PublicPort")]
    pub public_port: u16,
    #[serde(rename = "Type")]
    pub type_: ContainerListPortsType,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PortBinding {
    #[serde(rename = "HostIp")]
    pub host_ip: String,
    #[serde(rename = "HostPort")]
    pub host_port: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ProcessConfig {
    #[serde(rename = "privileged")]
    pub privileged: bool,
    #[serde(rename = "user")]
    pub user: String,
    #[serde(rename = "tty")]
    pub tty: bool,
    #[serde(rename = "entrypoint")]
    pub entrypoint: String,
    #[serde(rename = "arguments")]
    pub arguments: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ProgressDetail {
    #[serde(rename = "current")]
    pub current: i64,
    #[serde(rename = "total")]
    pub total: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct PushImageInfo {
    #[serde(rename = "error")]
    pub error: String,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "progress")]
    pub progress: String,
    #[serde(rename = "progressDetail")]
    pub progress_detail: ProgressDetail,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Reachability {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "unreachable")]
    Unreachable,
    #[serde(rename = "reachable")]
    Reachable,
}

impl ToString for Reachability {
    fn to_string(&self) -> String {
        match self {
            Reachability::Unknown => "unknown",
            Reachability::Unreachable => "unreachable",
            Reachability::Reachable => "reachable",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct RegistryServiceConfig {
    #[serde(rename = "AllowNondistributableArtifactsCIDRs")]
    pub allow_nondistributable_artifacts_cid_rs: Vec<String>,
    #[serde(rename = "AllowNondistributableArtifactsHostnames")]
    pub allow_nondistributable_artifacts_hostnames: Vec<String>,
    #[serde(rename = "InsecureRegistryCIDRs")]
    pub insecure_registry_cid_rs: Vec<String>,
    #[serde(rename = "IndexConfigs")]
    pub index_configs: ::serde_json::Value,
    #[serde(rename = "Mirrors")]
    pub mirrors: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceObject {
    #[serde(rename = "NanoCPUs")]
    pub nano_cp_us: i64,
    #[serde(rename = "MemoryBytes")]
    pub memory_bytes: i64,
    #[serde(rename = "GenericResources")]
    pub generic_resources: Vec<SystemInfoGenericResources>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Resources {
    #[serde(rename = "CpuShares")]
    pub cpu_shares: i64,
    #[serde(rename = "Memory")]
    pub memory: i64,
    #[serde(rename = "CgroupParent")]
    pub cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    pub blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    pub blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    pub blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    pub blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    pub blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    pub blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    pub cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    pub cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    pub cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    pub cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    pub cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    pub cpuset_mems: String,
    #[serde(rename = "Devices")]
    pub devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    pub device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    pub disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    pub kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    pub memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    pub memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    pub memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    pub nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    pub oom_kill_disable: bool,
    #[serde(rename = "Init")]
    pub init: bool,
    #[serde(rename = "PidsLimit")]
    pub pids_limit: i64,
    #[serde(rename = "Ulimits")]
    pub ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    pub cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    pub cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    pub io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    pub io_maximum_bandwidth: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct RestartPolicy {
    #[serde(rename = "Name")]
    pub name: ContainerCreateHostConfigRestartPolicyName,
    #[serde(rename = "MaximumRetryCount")]
    pub maximum_retry_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Runtime {
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "runtimeArgs")]
    pub runtime_args: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Secret {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: SecretSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Data")]
    pub data: String,
    #[serde(rename = "Driver")]
    pub driver: Driver,
    #[serde(rename = "Templating")]
    pub templating: Driver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Service {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: ServiceSpec,
    #[serde(rename = "Endpoint")]
    pub endpoint: ServiceListEndpoint,
    #[serde(rename = "UpdateStatus")]
    pub update_status: ServiceListUpdateStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceCreate {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Warning")]
    pub warning: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListEndpoint {
    #[serde(rename = "Spec")]
    pub spec: EndpointSpec,
    #[serde(rename = "Ports")]
    pub ports: Vec<EndpointPortConfig>,
    #[serde(rename = "VirtualIPs")]
    pub virtual_i_ps: Vec<ServiceListEndpointVirtualIPs>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListEndpointVirtualIPs {
    #[serde(rename = "NetworkID")]
    pub network_id: String,
    #[serde(rename = "Addr")]
    pub addr: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecEndpointSpecMode {
    #[serde(rename = "vip")]
    Vip,
    #[serde(rename = "dnsrr")]
    Dnsrr,
}

impl Default for ServiceListSpecEndpointSpecMode {
    fn default() -> Self {
        ServiceListSpecEndpointSpecMode::Vip
    }
}

impl ToString for ServiceListSpecEndpointSpecMode {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecEndpointSpecMode::Vip => "vip",
            ServiceListSpecEndpointSpecMode::Dnsrr => "dnsrr",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecEndpointSpecPortsPublishMode {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "host")]
    Host,
}

impl Default for ServiceListSpecEndpointSpecPortsPublishMode {
    fn default() -> Self {
        ServiceListSpecEndpointSpecPortsPublishMode::Ingress
    }
}

impl ToString for ServiceListSpecEndpointSpecPortsPublishMode {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecEndpointSpecPortsPublishMode::Ingress => "ingress",
            ServiceListSpecEndpointSpecPortsPublishMode::Host => "host",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecMode {
    #[serde(rename = "Replicated")]
    pub replicated: ServiceListSpecModeReplicated,
    #[serde(rename = "Global")]
    pub global: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecModeReplicated {
    #[serde(rename = "Replicas")]
    pub replicas: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecRollbackConfig {
    #[serde(rename = "Parallelism")]
    pub parallelism: i64,
    #[serde(rename = "Delay")]
    pub delay: i64,
    #[serde(rename = "FailureAction")]
    pub failure_action: ServiceListSpecRollbackConfigFailureAction,
    #[serde(rename = "Monitor")]
    pub monitor: i64,
    #[serde(rename = "MaxFailureRatio")]
    pub max_failure_ratio: f64,
    #[serde(rename = "Order")]
    pub order: ServiceListSpecUpdateConfigOrder,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecRollbackConfigFailureAction {
    #[serde(rename = "continue")]
    Continue,
    #[serde(rename = "pause")]
    Pause,
}

impl ToString for ServiceListSpecRollbackConfigFailureAction {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecRollbackConfigFailureAction::Continue => "continue",
            ServiceListSpecRollbackConfigFailureAction::Pause => "pause",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpec {
    #[serde(rename = "Image")]
    pub image: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Command")]
    pub command: Vec<String>,
    #[serde(rename = "Args")]
    pub args: Vec<String>,
    #[serde(rename = "Hostname")]
    pub hostname: String,
    #[serde(rename = "Env")]
    pub env: Vec<String>,
    #[serde(rename = "Dir")]
    pub dir: String,
    #[serde(rename = "User")]
    pub user: String,
    #[serde(rename = "Groups")]
    pub groups: Vec<String>,
    #[serde(rename = "Privileges")]
    pub privileges: ServiceListSpecTaskTemplateContainerSpecPrivileges,
    #[serde(rename = "TTY")]
    pub tty: bool,
    #[serde(rename = "OpenStdin")]
    pub open_stdin: bool,
    #[serde(rename = "ReadOnly")]
    pub read_only: bool,
    #[serde(rename = "Mounts")]
    pub mounts: Vec<Mount>,
    #[serde(rename = "StopSignal")]
    pub stop_signal: String,
    #[serde(rename = "StopGracePeriod")]
    pub stop_grace_period: i64,
    #[serde(rename = "HealthCheck")]
    pub health_check: HealthConfig,
    #[serde(rename = "Hosts")]
    pub hosts: Vec<String>,
    #[serde(rename = "DNSConfig")]
    pub dns_config: ServiceListSpecTaskTemplateContainerSpecDNSConfig,
    #[serde(rename = "Secrets")]
    pub secrets: Vec<ServiceListSpecTaskTemplateContainerSpecSecrets>,
    #[serde(rename = "Configs")]
    pub configs: Vec<ServiceListSpecTaskTemplateContainerSpecConfigs>,
    #[serde(rename = "Isolation")]
    pub isolation: ContainerCreateHostConfigIsolation,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecConfigs {
    #[serde(rename = "File")]
    pub file: ServiceListSpecTaskTemplateContainerSpecSecretsFile,
    #[serde(rename = "ConfigID")]
    pub config_id: String,
    #[serde(rename = "ConfigName")]
    pub config_name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecDNSConfig {
    #[serde(rename = "Nameservers")]
    pub nameservers: Vec<String>,
    #[serde(rename = "Search")]
    pub search: Vec<String>,
    #[serde(rename = "Options")]
    pub options: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecPrivileges {
    #[serde(rename = "CredentialSpec")]
    pub credential_spec: ServiceListSpecTaskTemplateContainerSpecPrivilegesCredentialSpec,
    #[serde(rename = "SELinuxContext")]
    pub se_linux_context: ServiceListSpecTaskTemplateContainerSpecPrivilegesSELinuxContext,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecPrivilegesCredentialSpec {
    #[serde(rename = "File")]
    pub file: String,
    #[serde(rename = "Registry")]
    pub registry: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecPrivilegesSELinuxContext {
    #[serde(rename = "Disable")]
    pub disable: bool,
    #[serde(rename = "User")]
    pub user: String,
    #[serde(rename = "Role")]
    pub role: String,
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Level")]
    pub level: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecSecrets {
    #[serde(rename = "File")]
    pub file: ServiceListSpecTaskTemplateContainerSpecSecretsFile,
    #[serde(rename = "SecretID")]
    pub secret_id: String,
    #[serde(rename = "SecretName")]
    pub secret_name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateContainerSpecSecretsFile {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "UID")]
    pub uid: String,
    #[serde(rename = "GID")]
    pub gid: String,
    #[serde(rename = "Mode")]
    pub mode: u32,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateLogDriver {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateNetworkAttachmentSpec {
    #[serde(rename = "ContainerID")]
    pub container_id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateNetworks {
    #[serde(rename = "Target")]
    pub target: String,
    #[serde(rename = "Aliases")]
    pub aliases: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplatePlacement {
    #[serde(rename = "Constraints")]
    pub constraints: Vec<String>,
    #[serde(rename = "Preferences")]
    pub preferences: Vec<ServiceListSpecTaskTemplatePlacementPreferences>,
    #[serde(rename = "Platforms")]
    pub platforms: Vec<Platform>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplatePlacementPreferences {
    #[serde(rename = "Spread")]
    pub spread: ServiceListSpecTaskTemplatePlacementPreferencesSpread,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplatePlacementPreferencesSpread {
    #[serde(rename = "SpreadDescriptor")]
    pub spread_descriptor: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplatePluginSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Remote")]
    pub remote: String,
    #[serde(rename = "Disabled")]
    pub disabled: bool,
    #[serde(rename = "PluginPrivilege")]
    pub plugin_privilege: Vec<GetPluginPrivileges>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateResources {
    #[serde(rename = "Limits")]
    pub limits: ResourceObject,
    #[serde(rename = "Reservation")]
    pub reservation: ResourceObject,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecTaskTemplateRestartPolicy {
    #[serde(rename = "Condition")]
    pub condition: ServiceListSpecTaskTemplateRestartPolicyCondition,
    #[serde(rename = "Delay")]
    pub delay: i64,
    #[serde(rename = "MaxAttempts")]
    pub max_attempts: i64,
    #[serde(rename = "Window")]
    pub window: i64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecTaskTemplateRestartPolicyCondition {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "on-failure")]
    Onfailure,
    #[serde(rename = "any")]
    Any,
}

impl ToString for ServiceListSpecTaskTemplateRestartPolicyCondition {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecTaskTemplateRestartPolicyCondition::None => "none",
            ServiceListSpecTaskTemplateRestartPolicyCondition::Onfailure => "on-failure",
            ServiceListSpecTaskTemplateRestartPolicyCondition::Any => "any",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListSpecUpdateConfig {
    #[serde(rename = "Parallelism")]
    pub parallelism: i64,
    #[serde(rename = "Delay")]
    pub delay: i64,
    #[serde(rename = "FailureAction")]
    pub failure_action: ServiceListSpecUpdateConfigFailureAction,
    #[serde(rename = "Monitor")]
    pub monitor: i64,
    #[serde(rename = "MaxFailureRatio")]
    pub max_failure_ratio: f64,
    #[serde(rename = "Order")]
    pub order: ServiceListSpecUpdateConfigOrder,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecUpdateConfigFailureAction {
    #[serde(rename = "continue")]
    Continue,
    #[serde(rename = "pause")]
    Pause,
    #[serde(rename = "rollback")]
    Rollback,
}

impl ToString for ServiceListSpecUpdateConfigFailureAction {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecUpdateConfigFailureAction::Continue => "continue",
            ServiceListSpecUpdateConfigFailureAction::Pause => "pause",
            ServiceListSpecUpdateConfigFailureAction::Rollback => "rollback",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListSpecUpdateConfigOrder {
    #[serde(rename = "stop-first")]
    Stopfirst,
    #[serde(rename = "start-first")]
    Startfirst,
}

impl ToString for ServiceListSpecUpdateConfigOrder {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecUpdateConfigOrder::Stopfirst => "stop-first",
            ServiceListSpecUpdateConfigOrder::Startfirst => "start-first",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceListUpdateStatus {
    #[serde(rename = "State")]
    pub state: ServiceListUpdateStatusState,
    #[serde(rename = "StartedAt")]
    pub started_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "CompletedAt")]
    pub completed_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Message")]
    pub message: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServiceListUpdateStatusState {
    #[serde(rename = "updating")]
    Updating,
    #[serde(rename = "paused")]
    Paused,
    #[serde(rename = "completed")]
    Completed,
}

impl ToString for ServiceListUpdateStatusState {
    fn to_string(&self) -> String {
        match self {
            ServiceListUpdateStatusState::Updating => "updating",
            ServiceListUpdateStatusState::Paused => "paused",
            ServiceListUpdateStatusState::Completed => "completed",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "TaskTemplate")]
    pub task_template: TaskSpec,
    #[serde(rename = "Mode")]
    pub mode: ServiceListSpecMode,
    #[serde(rename = "UpdateConfig")]
    pub update_config: ServiceListSpecUpdateConfig,
    #[serde(rename = "RollbackConfig")]
    pub rollback_config: ServiceListSpecRollbackConfig,
    #[serde(rename = "Networks")]
    pub networks: Vec<ServiceListSpecTaskTemplateNetworks>,
    #[serde(rename = "EndpointSpec")]
    pub endpoint_spec: EndpointSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceUpdateResponse {
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Swarm {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    pub spec: SwarmSpec,
    #[serde(rename = "TLSInfo")]
    pub tls_info: TLSInfo,
    #[serde(rename = "RootRotationInProgress")]
    pub root_rotation_in_progress: bool,
    #[serde(rename = "JoinTokens")]
    pub join_tokens: JoinTokens,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SwarmInfo {
    #[serde(rename = "NodeID")]
    pub node_id: String,
    #[serde(rename = "NodeAddr")]
    pub node_addr: String,
    #[serde(rename = "LocalNodeState")]
    pub local_node_state: LocalNodeState,
    #[serde(rename = "ControlAvailable")]
    pub control_available: bool,
    #[serde(rename = "Error")]
    pub error: String,
    #[serde(rename = "RemoteManagers")]
    pub remote_managers: Vec<PeerNode>,
    #[serde(rename = "Nodes")]
    pub nodes: i64,
    #[serde(rename = "Managers")]
    pub managers: i64,
    #[serde(rename = "Cluster")]
    pub cluster: ClusterInfo,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SwarmInit {
    #[serde(rename = "ListenAddr")]
    pub listen_addr: String,
    #[serde(rename = "AdvertiseAddr")]
    pub advertise_addr: String,
    #[serde(rename = "DataPathAddr")]
    pub data_path_addr: String,
    #[serde(rename = "ForceNewCluster")]
    pub force_new_cluster: bool,
    #[serde(rename = "Spec")]
    pub spec: SwarmSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SwarmJoin {
    #[serde(rename = "ListenAddr")]
    pub listen_addr: String,
    #[serde(rename = "AdvertiseAddr")]
    pub advertise_addr: String,
    #[serde(rename = "DataPathAddr")]
    pub data_path_addr: String,
    #[serde(rename = "RemoteAddrs")]
    pub remote_addrs: String,
    #[serde(rename = "JoinToken")]
    pub join_token: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SwarmSpec {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Orchestration")]
    pub orchestration: SystemInfoSwarmClusterSpecOrchestration,
    #[serde(rename = "Raft")]
    pub raft: SystemInfoSwarmClusterSpecRaft,
    #[serde(rename = "Dispatcher")]
    pub dispatcher: SystemInfoSwarmClusterSpecDispatcher,
    #[serde(rename = "CAConfig")]
    pub ca_config: SystemInfoSwarmClusterSpecCAConfig,
    #[serde(rename = "EncryptionConfig")]
    pub encryption_config: SystemInfoSwarmClusterSpecEncryptionConfig,
    #[serde(rename = "TaskDefaults")]
    pub task_defaults: SystemInfoSwarmClusterSpecTaskDefaults,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SwarmUnlockkey {
    #[serde(rename = "UnlockKey")]
    pub unlock_key: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemAuth {
    #[serde(rename = "Status")]
    pub status: String,
    #[serde(rename = "IdentityToken")]
    pub identity_token: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemDataUsage {
    #[serde(rename = "LayersSize")]
    pub layers_size: i64,
    #[serde(rename = "Images")]
    pub images: Vec<ImageSummary>,
    #[serde(rename = "Containers")]
    pub containers: Vec<Vec<ContainerList>>,
    #[serde(rename = "Volumes")]
    pub volumes: Vec<Volume>,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SystemDataUsageVolumesScope {
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "global")]
    Global,
}

impl Default for SystemDataUsageVolumesScope {
    fn default() -> Self {
        SystemDataUsageVolumesScope::Local
    }
}

impl ToString for SystemDataUsageVolumesScope {
    fn to_string(&self) -> String {
        match self {
            SystemDataUsageVolumesScope::Local => "local",
            SystemDataUsageVolumesScope::Global => "global",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemDataUsageVolumesUsageData {
    #[serde(rename = "Size")]
    pub size: i64,
    #[serde(rename = "RefCount")]
    pub ref_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemEvents {
    #[serde(rename = "Type")]
    pub type_: String,
    #[serde(rename = "Action")]
    pub action: String,
    #[serde(rename = "Actor")]
    pub actor: SystemEventsActor,
    #[serde(rename = "time")]
    pub time: i64,
    #[serde(rename = "timeNano")]
    pub time_nano: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemEventsActor {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Attributes")]
    pub attributes: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfo {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Containers")]
    pub containers: i64,
    #[serde(rename = "ContainersRunning")]
    pub containers_running: i64,
    #[serde(rename = "ContainersPaused")]
    pub containers_paused: i64,
    #[serde(rename = "ContainersStopped")]
    pub containers_stopped: i64,
    #[serde(rename = "Images")]
    pub images: i64,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "DriverStatus")]
    pub driver_status: Vec<Vec<String>>,
    #[serde(rename = "DockerRootDir")]
    pub docker_root_dir: String,
    #[serde(rename = "SystemStatus")]
    pub system_status: Vec<Vec<String>>,
    #[serde(rename = "Plugins")]
    pub plugins: PluginsInfo,
    #[serde(rename = "MemoryLimit")]
    pub memory_limit: bool,
    #[serde(rename = "SwapLimit")]
    pub swap_limit: bool,
    #[serde(rename = "KernelMemory")]
    pub kernel_memory: bool,
    #[serde(rename = "CpuCfsPeriod")]
    pub cpu_cfs_period: bool,
    #[serde(rename = "CpuCfsQuota")]
    pub cpu_cfs_quota: bool,
    #[serde(rename = "CPUShares")]
    pub cpu_shares: bool,
    #[serde(rename = "CPUSet")]
    pub cpu_set: bool,
    #[serde(rename = "OomKillDisable")]
    pub oom_kill_disable: bool,
    #[serde(rename = "IPv4Forwarding")]
    pub i_pv4_forwarding: bool,
    #[serde(rename = "BridgeNfIptables")]
    pub bridge_nf_iptables: bool,
    #[serde(rename = "BridgeNfIp6tables")]
    pub bridge_nf_ip6tables: bool,
    #[serde(rename = "Debug")]
    pub debug: bool,
    #[serde(rename = "NFd")]
    pub n_fd: i64,
    #[serde(rename = "NGoroutines")]
    pub n_goroutines: i64,
    #[serde(rename = "SystemTime")]
    pub system_time: String,
    #[serde(rename = "LoggingDriver")]
    pub logging_driver: String,
    #[serde(rename = "CgroupDriver")]
    pub cgroup_driver: SystemInfoCgroupDriver,
    #[serde(rename = "NEventsListener")]
    pub n_events_listener: i64,
    #[serde(rename = "KernelVersion")]
    pub kernel_version: String,
    #[serde(rename = "OperatingSystem")]
    pub operating_system: String,
    #[serde(rename = "OSType")]
    pub os_type: String,
    #[serde(rename = "Architecture")]
    pub architecture: String,
    #[serde(rename = "NCPU")]
    pub ncpu: i64,
    #[serde(rename = "MemTotal")]
    pub mem_total: i64,
    #[serde(rename = "IndexServerAddress")]
    pub index_server_address: String,
    #[serde(rename = "RegistryConfig")]
    pub registry_config: RegistryServiceConfig,
    #[serde(rename = "GenericResources")]
    pub generic_resources: Vec<SystemInfoGenericResources>,
    #[serde(rename = "HttpProxy")]
    pub http_proxy: String,
    #[serde(rename = "HttpsProxy")]
    pub https_proxy: String,
    #[serde(rename = "NoProxy")]
    pub no_proxy: String,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: Vec<String>,
    #[serde(rename = "ExperimentalBuild")]
    pub experimental_build: bool,
    #[serde(rename = "ServerVersion")]
    pub server_version: String,
    #[serde(rename = "ClusterStore")]
    pub cluster_store: String,
    #[serde(rename = "ClusterAdvertise")]
    pub cluster_advertise: String,
    #[serde(rename = "Runtimes")]
    pub runtimes: ::serde_json::Value,
    #[serde(rename = "DefaultRuntime")]
    pub default_runtime: String,
    #[serde(rename = "Swarm")]
    pub swarm: SwarmInfo,
    #[serde(rename = "LiveRestoreEnabled")]
    pub live_restore_enabled: bool,
    #[serde(rename = "Isolation")]
    pub isolation: SystemInfoIsolation,
    #[serde(rename = "InitBinary")]
    pub init_binary: String,
    #[serde(rename = "ContainerdCommit")]
    pub containerd_commit: Commit,
    #[serde(rename = "RuncCommit")]
    pub runc_commit: Commit,
    #[serde(rename = "InitCommit")]
    pub init_commit: Commit,
    #[serde(rename = "SecurityOptions")]
    pub security_options: Vec<String>,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SystemInfoCgroupDriver {
    #[serde(rename = "cgroupfs")]
    Cgroupfs,
    #[serde(rename = "systemd")]
    Systemd,
}

impl Default for SystemInfoCgroupDriver {
    fn default() -> Self {
        SystemInfoCgroupDriver::Cgroupfs
    }
}

impl ToString for SystemInfoCgroupDriver {
    fn to_string(&self) -> String {
        match self {
            SystemInfoCgroupDriver::Cgroupfs => "cgroupfs",
            SystemInfoCgroupDriver::Systemd => "systemd",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoGenericResources {
    #[serde(rename = "NamedResourceSpec")]
    pub named_resource_spec: SystemInfoGenericResourcesNamedResourceSpec,
    #[serde(rename = "DiscreteResourceSpec")]
    pub discrete_resource_spec: SystemInfoGenericResourcesDiscreteResourceSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoGenericResourcesDiscreteResourceSpec {
    #[serde(rename = "Kind")]
    pub kind: String,
    #[serde(rename = "Value")]
    pub value: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoGenericResourcesNamedResourceSpec {
    #[serde(rename = "Kind")]
    pub kind: String,
    #[serde(rename = "Value")]
    pub value: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SystemInfoIsolation {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "hyperv")]
    Hyperv,
    #[serde(rename = "process")]
    Process,
}

impl Default for SystemInfoIsolation {
    fn default() -> Self {
        SystemInfoIsolation::Default
    }
}

impl ToString for SystemInfoIsolation {
    fn to_string(&self) -> String {
        match self {
            SystemInfoIsolation::Default => "default",
            SystemInfoIsolation::Hyperv => "hyperv",
            SystemInfoIsolation::Process => "process",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecCAConfig {
    #[serde(rename = "NodeCertExpiry")]
    pub node_cert_expiry: i64,
    #[serde(rename = "ExternalCAs")]
    pub external_c_as: Vec<SystemInfoSwarmClusterSpecCAConfigExternalCAs>,
    #[serde(rename = "SigningCACert")]
    pub signing_ca_cert: String,
    #[serde(rename = "SigningCAKey")]
    pub signing_ca_key: String,
    #[serde(rename = "ForceRotate")]
    pub force_rotate: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecCAConfigExternalCAs {
    #[serde(rename = "Protocol")]
    pub protocol: SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol,
    #[serde(rename = "URL")]
    pub url: String,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
    #[serde(rename = "CACert")]
    pub ca_cert: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    #[serde(rename = "cfssl")]
    Cfssl,
}

impl Default for SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    fn default() -> Self {
        SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol::Cfssl
    }
}

impl ToString for SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    fn to_string(&self) -> String {
        match self {
            SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol::Cfssl => "cfssl",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecDispatcher {
    #[serde(rename = "HeartbeatPeriod")]
    pub heartbeat_period: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecEncryptionConfig {
    #[serde(rename = "AutoLockManagers")]
    pub auto_lock_managers: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecOrchestration {
    #[serde(rename = "TaskHistoryRetentionLimit")]
    pub task_history_retention_limit: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecRaft {
    #[serde(rename = "SnapshotInterval")]
    pub snapshot_interval: u64,
    #[serde(rename = "KeepOldSnapshots")]
    pub keep_old_snapshots: u64,
    #[serde(rename = "LogEntriesForSlowFollowers")]
    pub log_entries_for_slow_followers: u64,
    #[serde(rename = "ElectionTick")]
    pub election_tick: i64,
    #[serde(rename = "HeartbeatTick")]
    pub heartbeat_tick: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecTaskDefaults {
    #[serde(rename = "LogDriver")]
    pub log_driver: SystemInfoSwarmClusterSpecTaskDefaultsLogDriver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemInfoSwarmClusterSpecTaskDefaultsLogDriver {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemVersion {
    #[serde(rename = "Platform")]
    pub platform: SystemVersionPlatform,
    #[serde(rename = "Components")]
    pub components: Vec<SystemVersionComponents>,
    #[serde(rename = "Version")]
    pub version: String,
    #[serde(rename = "ApiVersion")]
    pub api_version: String,
    #[serde(rename = "MinAPIVersion")]
    pub min_api_version: String,
    #[serde(rename = "GitCommit")]
    pub git_commit: String,
    #[serde(rename = "GoVersion")]
    pub go_version: String,
    #[serde(rename = "Os")]
    pub os: String,
    #[serde(rename = "Arch")]
    pub arch: String,
    #[serde(rename = "KernelVersion")]
    pub kernel_version: String,
    #[serde(rename = "Experimental")]
    pub experimental: bool,
    #[serde(rename = "BuildTime")]
    pub build_time: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemVersionComponents {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Version")]
    pub version: String,
    #[serde(rename = "Details")]
    pub details: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct SystemVersionPlatform {
    #[serde(rename = "Name")]
    pub name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct TLSInfo {
    #[serde(rename = "TrustRoot")]
    pub trust_root: String,
    #[serde(rename = "CertIssuerSubject")]
    pub cert_issuer_subject: String,
    #[serde(rename = "CertIssuerPublicKey")]
    pub cert_issuer_public_key: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Task {
    #[serde(rename = "ID")]
    pub id: String,
    #[serde(rename = "Version")]
    pub version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    pub updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Spec")]
    pub spec: TaskSpec,
    #[serde(rename = "ServiceID")]
    pub service_id: String,
    #[serde(rename = "Slot")]
    pub slot: i64,
    #[serde(rename = "NodeID")]
    pub node_id: String,
    #[serde(rename = "AssignedGenericResources")]
    pub assigned_generic_resources: Vec<SystemInfoGenericResources>,
    #[serde(rename = "Status")]
    pub status: TaskListStatus,
    #[serde(rename = "DesiredState")]
    pub desired_state: TaskState,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskListStatus {
    #[serde(rename = "Timestamp")]
    pub timestamp: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "State")]
    pub state: TaskState,
    #[serde(rename = "Message")]
    pub message: String,
    #[serde(rename = "Err")]
    pub err: String,
    #[serde(rename = "ContainerStatus")]
    pub container_status: TaskListStatusContainerStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskListStatusContainerStatus {
    #[serde(rename = "ContainerID")]
    pub container_id: String,
    #[serde(rename = "PID")]
    pub pid: i64,
    #[serde(rename = "ExitCode")]
    pub exit_code: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskSpec {
    #[serde(rename = "PluginSpec")]
    pub plugin_spec: ServiceListSpecTaskTemplatePluginSpec,
    #[serde(rename = "ContainerSpec")]
    pub container_spec: ServiceListSpecTaskTemplateContainerSpec,
    #[serde(rename = "NetworkAttachmentSpec")]
    pub network_attachment_spec: ServiceListSpecTaskTemplateNetworkAttachmentSpec,
    #[serde(rename = "Resources")]
    pub resources: ServiceListSpecTaskTemplateResources,
    #[serde(rename = "RestartPolicy")]
    pub restart_policy: ServiceListSpecTaskTemplateRestartPolicy,
    #[serde(rename = "Placement")]
    pub placement: ServiceListSpecTaskTemplatePlacement,
    #[serde(rename = "ForceUpdate")]
    pub force_update: i64,
    #[serde(rename = "Runtime")]
    pub runtime: String,
    #[serde(rename = "Networks")]
    pub networks: Vec<ServiceListSpecTaskTemplateNetworks>,
    #[serde(rename = "LogDriver")]
    pub log_driver: ServiceListSpecTaskTemplateLogDriver,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TaskState {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "allocated")]
    Allocated,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "assigned")]
    Assigned,
    #[serde(rename = "accepted")]
    Accepted,
    #[serde(rename = "preparing")]
    Preparing,
    #[serde(rename = "ready")]
    Ready,
    #[serde(rename = "starting")]
    Starting,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "shutdown")]
    Shutdown,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "rejected")]
    Rejected,
    #[serde(rename = "remove")]
    Remove,
    #[serde(rename = "orphaned")]
    Orphaned,
}

impl ToString for TaskState {
    fn to_string(&self) -> String {
        match self {
            TaskState::New => "new",
            TaskState::Allocated => "allocated",
            TaskState::Pending => "pending",
            TaskState::Assigned => "assigned",
            TaskState::Accepted => "accepted",
            TaskState::Preparing => "preparing",
            TaskState::Ready => "ready",
            TaskState::Starting => "starting",
            TaskState::Running => "running",
            TaskState::Complete => "complete",
            TaskState::Shutdown => "shutdown",
            TaskState::Failed => "failed",
            TaskState::Rejected => "rejected",
            TaskState::Remove => "remove",
            TaskState::Orphaned => "orphaned",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct ThrottleDevice {
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Rate")]
    pub rate: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct Volume {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "Mountpoint")]
    pub mountpoint: String,
    #[serde(rename = "CreatedAt")]
    pub created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Status")]
    pub status: ::serde_json::Value,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
    #[serde(rename = "Scope")]
    pub scope: SystemDataUsageVolumesScope,
    #[serde(rename = "Options")]
    pub options: ::serde_json::Value,
    #[serde(rename = "UsageData")]
    pub usage_data: SystemDataUsageVolumesUsageData,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct VolumeCreate {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Driver")]
    pub driver: String,
    #[serde(rename = "DriverOpts")]
    pub driver_opts: ::serde_json::Value,
    #[serde(rename = "Labels")]
    pub labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct VolumeList {
    #[serde(rename = "Volumes")]
    pub volumes: Vec<Volume>,
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct VolumePrune {
    #[serde(rename = "VolumesDeleted")]
    pub volumes_deleted: Vec<String>,
    #[serde(rename = "SpaceReclaimed")]
    pub space_reclaimed: i64,
}

#[derive(Clone, PartialEq)]
pub enum ContainerListCodes {
    /// no error
    Ok(Vec<ContainerList>),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_list(
    client: &Client,
    all: Option<bool>,
    limit: Option<i64>,
    size: Option<bool>,
    filters: Option<&str>,
) -> Result<ContainerListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(4);
        if let Some(all) = all {
            params.push(("all", all.to_string()));
        }
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(limit) = limit {
            params.push(("limit", limit.to_string()));
        }
        if let Some(size) = size {
            params.push(("size", size.to_string()));
        }
        Url::parse_with_params("/containers/json", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerListCodes::Ok(resp.json()?),
        400 => ContainerListCodes::BadRequest(resp.json()?),
        500 => ContainerListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerCreateCodes {
    /// Container created successfully
    Created(ContainerCreateCreated),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// conflict
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_create(
    client: &Client,
    name: Option<&str>,
    body: &ContainerCreateBody,
) -> Result<ContainerCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(name) = name {
            params.push(("name", name.to_string()));
        }
        Url::parse_with_params("/containers/create", &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ContainerCreateCodes::Created(resp.json()?),
        400 => ContainerCreateCodes::BadRequest(resp.json()?),
        404 => ContainerCreateCodes::NotFound(resp.json()?),
        409 => ContainerCreateCodes::Conflict(resp.json()?),
        500 => ContainerCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerInspectCodes {
    /// no error
    Ok(ContainerInspect),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_inspect(
    client: &Client,
    id: &str,
    size: Option<bool>,
) -> Result<ContainerInspectCodes, Error> {
    let url = format!("/containers/{id}/json",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(size) = size {
            params.push(("size", size.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerInspectCodes::Ok(resp.json()?),
        404 => ContainerInspectCodes::NotFound(resp.json()?),
        500 => ContainerInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerTopCodes {
    /// no error
    Ok(ContainerTop),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_top(
    client: &Client,
    id: &str,
    ps_args: Option<&str>,
) -> Result<ContainerTopCodes, Error> {
    let url = format!("/containers/{id}/top",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(ps_args) = ps_args {
            params.push(("ps_args", ps_args.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerTopCodes::Ok(resp.json()?),
        404 => ContainerTopCodes::NotFound(resp.json()?),
        500 => ContainerTopCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_logs(
    client: &Client,
    id: &str,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    until: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ContainerLogsCodes, Error> {
    let url = format!("/containers/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        if let Some(until) = until {
            params.push(("until", until.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerLogsCodes::SwitchingProtocols(resp.json()?),
        200 => ContainerLogsCodes::Ok(resp.json()?),
        404 => ContainerLogsCodes::NotFound(resp.json()?),
        500 => ContainerLogsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerChangesCodes {
    /// The list of changes
    Ok(Vec<ContainerChanges>),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_changes(
    client: &Client,
    id: &str,
) -> Result<ContainerChangesCodes, Error> {
    let url = format!("/containers/{id}/changes",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerChangesCodes::Ok(resp.json()?),
        404 => ContainerChangesCodes::NotFound(resp.json()?),
        500 => ContainerChangesCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerExportCodes {
    /// no error
    Ok,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_export(
    client: &Client,
    id: &str,
) -> Result<ContainerExportCodes, Error> {
    let url = format!("/containers/{id}/export",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerExportCodes::Ok,
        404 => ContainerExportCodes::NotFound(resp.json()?),
        500 => ContainerExportCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerStatsCodes {
    /// no error
    Ok(::serde_json::Value),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_stats(
    client: &Client,
    id: &str,
    stream: Option<bool>,
) -> Result<ContainerStatsCodes, Error> {
    let url = format!("/containers/{id}/stats",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerStatsCodes::Ok(resp.json()?),
        404 => ContainerStatsCodes::NotFound(resp.json()?),
        500 => ContainerStatsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerResizeCodes {
    /// no error
    Ok,
    /// no such container
    NotFound(ErrorResponse),
    /// cannot resize container
    ServerError(ErrorResponse),
}

pub fn container_resize(
    client: &Client,
    id: &str,
    h: Option<i64>,
    w: Option<i64>,
) -> Result<ContainerResizeCodes, Error> {
    let url = format!("/containers/{id}/resize",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(h) = h {
            params.push(("h", h.to_string()));
        }
        if let Some(w) = w {
            params.push(("w", w.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerResizeCodes::Ok,
        404 => ContainerResizeCodes::NotFound(resp.json()?),
        500 => ContainerResizeCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerStartCodes {
    /// no error
    NoContent,
    /// container already started
    NotModified(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_start(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
) -> Result<ContainerStartCodes, Error> {
    let url = format!("/containers/{id}/start",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerStartCodes::NoContent,
        304 => ContainerStartCodes::NotModified(resp.json()?),
        404 => ContainerStartCodes::NotFound(resp.json()?),
        500 => ContainerStartCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerStopCodes {
    /// no error
    NoContent,
    /// container already stopped
    NotModified(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_stop(
    client: &Client,
    id: &str,
    t: Option<i64>,
) -> Result<ContainerStopCodes, Error> {
    let url = format!("/containers/{id}/stop",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerStopCodes::NoContent,
        304 => ContainerStopCodes::NotModified(resp.json()?),
        404 => ContainerStopCodes::NotFound(resp.json()?),
        500 => ContainerStopCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerRestartCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_restart(
    client: &Client,
    id: &str,
    t: Option<i64>,
) -> Result<ContainerRestartCodes, Error> {
    let url = format!("/containers/{id}/restart",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerRestartCodes::NoContent,
        404 => ContainerRestartCodes::NotFound(resp.json()?),
        500 => ContainerRestartCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerKillCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// container is not running
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_kill(
    client: &Client,
    id: &str,
    signal: Option<&str>,
) -> Result<ContainerKillCodes, Error> {
    let url = format!("/containers/{id}/kill",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(signal) = signal {
            params.push(("signal", signal.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerKillCodes::NoContent,
        404 => ContainerKillCodes::NotFound(resp.json()?),
        409 => ContainerKillCodes::Conflict(resp.json()?),
        500 => ContainerKillCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerUpdateCodes {
    /// The container has been updated.
    Ok(ContainerUpdateOk),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_update(
    client: &Client,
    id: &str,
    update: &ContainerUpdateUpdate,
) -> Result<ContainerUpdateCodes, Error> {
    let url = format!("/containers/{id}/update",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(update)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerUpdateCodes::Ok(resp.json()?),
        404 => ContainerUpdateCodes::NotFound(resp.json()?),
        500 => ContainerUpdateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerRenameCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// name already in use
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_rename(
    client: &Client,
    id: &str,
    name: &str,
) -> Result<ContainerRenameCodes, Error> {
    let url = format!("/containers/{id}/rename",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("name", name.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerRenameCodes::NoContent,
        404 => ContainerRenameCodes::NotFound(resp.json()?),
        409 => ContainerRenameCodes::Conflict(resp.json()?),
        500 => ContainerRenameCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerPauseCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_pause(
    client: &Client,
    id: &str,
) -> Result<ContainerPauseCodes, Error> {
    let url = format!("/containers/{id}/pause",
        id=id,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerPauseCodes::NoContent,
        404 => ContainerPauseCodes::NotFound(resp.json()?),
        500 => ContainerPauseCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerUnpauseCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_unpause(
    client: &Client,
    id: &str,
) -> Result<ContainerUnpauseCodes, Error> {
    let url = format!("/containers/{id}/unpause",
        id=id,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerUnpauseCodes::NoContent,
        404 => ContainerUnpauseCodes::NotFound(resp.json()?),
        500 => ContainerUnpauseCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerAttachCodes {
    /// no error, hints proxy about hijacking
    SwitchingProtocols,
    /// no error, no upgrade header found
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_attach(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdin: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
) -> Result<ContainerAttachCodes, Error> {
    let url = format!("/containers/{id}/attach",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(6);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        if let Some(logs) = logs {
            params.push(("logs", logs.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdin) = stdin {
            params.push(("stdin", stdin.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerAttachCodes::SwitchingProtocols,
        200 => ContainerAttachCodes::Ok,
        400 => ContainerAttachCodes::BadRequest(resp.json()?),
        404 => ContainerAttachCodes::NotFound(resp.json()?),
        500 => ContainerAttachCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerAttachWebsocketCodes {
    /// no error, hints proxy about hijacking
    SwitchingProtocols,
    /// no error, no upgrade header found
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_attach_websocket(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdin: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
) -> Result<ContainerAttachWebsocketCodes, Error> {
    let url = format!("/containers/{id}/attach/ws",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(6);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        if let Some(logs) = logs {
            params.push(("logs", logs.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdin) = stdin {
            params.push(("stdin", stdin.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerAttachWebsocketCodes::SwitchingProtocols,
        200 => ContainerAttachWebsocketCodes::Ok,
        400 => ContainerAttachWebsocketCodes::BadRequest(resp.json()?),
        404 => ContainerAttachWebsocketCodes::NotFound(resp.json()?),
        500 => ContainerAttachWebsocketCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerWaitCodes {
    /// The container has exit.
    Ok(ContainerWait),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_wait(
    client: &Client,
    id: &str,
    condition: Option<&str>,
) -> Result<ContainerWaitCodes, Error> {
    let url = format!("/containers/{id}/wait",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(condition) = condition {
            params.push(("condition", condition.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerWaitCodes::Ok(resp.json()?),
        404 => ContainerWaitCodes::NotFound(resp.json()?),
        500 => ContainerWaitCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerDeleteCodes {
    /// no error
    NoContent,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// conflict
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_delete(
    client: &Client,
    id: &str,
    v: Option<bool>,
    force: Option<bool>,
    link: Option<bool>,
) -> Result<ContainerDeleteCodes, Error> {
    let url = format!("/containers/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        if let Some(link) = link {
            params.push(("link", link.to_string()));
        }
        if let Some(v) = v {
            params.push(("v", v.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerDeleteCodes::NoContent,
        400 => ContainerDeleteCodes::BadRequest(resp.json()?),
        404 => ContainerDeleteCodes::NotFound(resp.json()?),
        409 => ContainerDeleteCodes::Conflict(resp.json()?),
        500 => ContainerDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerArchiveCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Container or path does not exist
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn container_archive(
    client: &Client,
    id: &str,
    path: &str,
) -> Result<ContainerArchiveCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerArchiveCodes::Ok,
        400 => ContainerArchiveCodes::BadRequest(resp.json()?),
        404 => ContainerArchiveCodes::NotFound(resp.json()?),
        500 => ContainerArchiveCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerArchiveInfoCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Container or path does not exist
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn container_archive_info(
    client: &Client,
    id: &str,
    path: &str,
) -> Result<ContainerArchiveInfoCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.head(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerArchiveInfoCodes::Ok,
        400 => ContainerArchiveInfoCodes::BadRequest(resp.json()?),
        404 => ContainerArchiveInfoCodes::NotFound(resp.json()?),
        500 => ContainerArchiveInfoCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PutContainerArchiveCodes {
    /// The content was extracted successfully
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Permission denied, the volume or container rootfs is marked as read-only.
    Forbidden(ErrorResponse),
    /// No such container or path does not exist inside the container
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn put_container_archive(
    client: &Client,
    id: &str,
    path: &str,
    no_overwrite_dir_non_dir: Option<&str>,
    input_stream: &str,
) -> Result<PutContainerArchiveCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(no_overwrite_dir_non_dir) = no_overwrite_dir_non_dir {
            params.push(("no_overwrite_dir_non_dir", no_overwrite_dir_non_dir.to_string()));
        }
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.put(url)
        .json(input_stream)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PutContainerArchiveCodes::Ok,
        400 => PutContainerArchiveCodes::BadRequest(resp.json()?),
        403 => PutContainerArchiveCodes::Forbidden(resp.json()?),
        404 => PutContainerArchiveCodes::NotFound(resp.json()?),
        500 => PutContainerArchiveCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerPruneCodes {
    /// No error
    Ok(ContainerPrune),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn container_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<ContainerPruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/containers/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerPruneCodes::Ok(resp.json()?),
        500 => ContainerPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageListCodes {
    /// Summary image data for the images matching the query
    Ok(Vec<ImageSummary>),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_list(
    client: &Client,
    all: Option<bool>,
    filters: Option<&str>,
    digests: Option<bool>,
) -> Result<ImageListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(all) = all {
            params.push(("all", all.to_string()));
        }
        if let Some(digests) = digests {
            params.push(("digests", digests.to_string()));
        }
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/images/json", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageListCodes::Ok(resp.json()?),
        500 => ImageListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageBuildCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_build(
    client: &Client,
    input_stream: (/* binary */),
    dockerfile: Option<&str>,
    t: Option<&str>,
    extrahosts: Option<&str>,
    remote: Option<&str>,
    q: Option<bool>,
    nocache: Option<bool>,
    cachefrom: Option<&str>,
    pull: Option<&str>,
    rm: Option<bool>,
    forcerm: Option<bool>,
    memory: Option<i64>,
    memswap: Option<i64>,
    cpushares: Option<i64>,
    cpusetcpus: Option<&str>,
    cpuperiod: Option<i64>,
    cpuquota: Option<i64>,
    buildargs: Option<&str>,
    shmsize: Option<i64>,
    squash: Option<bool>,
    labels: Option<&str>,
    networkmode: Option<&str>,
    content_type: Option<&ImageBuild>,
    x_registry_config: Option<&str>,
    platform: Option<&str>,
    target: Option<&str>,
) -> Result<ImageBuildCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(23);
        if let Some(buildargs) = buildargs {
            params.push(("buildargs", buildargs.to_string()));
        }
        if let Some(cachefrom) = cachefrom {
            params.push(("cachefrom", cachefrom.to_string()));
        }
        if let Some(cpuperiod) = cpuperiod {
            params.push(("cpuperiod", cpuperiod.to_string()));
        }
        if let Some(cpuquota) = cpuquota {
            params.push(("cpuquota", cpuquota.to_string()));
        }
        if let Some(cpusetcpus) = cpusetcpus {
            params.push(("cpusetcpus", cpusetcpus.to_string()));
        }
        if let Some(cpushares) = cpushares {
            params.push(("cpushares", cpushares.to_string()));
        }
        if let Some(dockerfile) = dockerfile {
            params.push(("dockerfile", dockerfile.to_string()));
        }
        if let Some(extrahosts) = extrahosts {
            params.push(("extrahosts", extrahosts.to_string()));
        }
        if let Some(forcerm) = forcerm {
            params.push(("forcerm", forcerm.to_string()));
        }
        if let Some(labels) = labels {
            params.push(("labels", labels.to_string()));
        }
        if let Some(memory) = memory {
            params.push(("memory", memory.to_string()));
        }
        if let Some(memswap) = memswap {
            params.push(("memswap", memswap.to_string()));
        }
        if let Some(networkmode) = networkmode {
            params.push(("networkmode", networkmode.to_string()));
        }
        if let Some(nocache) = nocache {
            params.push(("nocache", nocache.to_string()));
        }
        if let Some(platform) = platform {
            params.push(("platform", platform.to_string()));
        }
        if let Some(pull) = pull {
            params.push(("pull", pull.to_string()));
        }
        if let Some(q) = q {
            params.push(("q", q.to_string()));
        }
        if let Some(remote) = remote {
            params.push(("remote", remote.to_string()));
        }
        if let Some(rm) = rm {
            params.push(("rm", rm.to_string()));
        }
        if let Some(shmsize) = shmsize {
            params.push(("shmsize", shmsize.to_string()));
        }
        if let Some(squash) = squash {
            params.push(("squash", squash.to_string()));
        }
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        if let Some(target) = target {
            params.push(("target", target.to_string()));
        }
        Url::parse_with_params("/build", &params)?
    };

    let mut headers = Headers::new();
    if let Some(content_type) = content_type {
        headers.set_raw("Content-type", content_type.to_string());
    }
    if let Some(x_registry_config) = x_registry_config {
        headers.set_raw("X-Registry-Config", x_registry_config.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageBuildCodes::Ok,
        400 => ImageBuildCodes::BadRequest(resp.json()?),
        500 => ImageBuildCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum BuildPruneCodes {
    /// No error
    Ok(BuildPrune),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn build_prune(
    client: &Client,
) -> Result<BuildPruneCodes, Error> {
    let mut resp = client.post("/build/prune")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => BuildPruneCodes::Ok(resp.json()?),
        500 => BuildPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageCreateCodes {
    /// no error
    Ok,
    /// repository does not exist or no read access
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_create(
    client: &Client,
    from_image: Option<&str>,
    from_src: Option<&str>,
    repo: Option<&str>,
    tag: Option<&str>,
    input_image: &str,
    x_registry_auth: Option<&str>,
    platform: Option<&str>,
) -> Result<ImageCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(5);
        if let Some(from_image) = from_image {
            params.push(("from_image", from_image.to_string()));
        }
        if let Some(from_src) = from_src {
            params.push(("from_src", from_src.to_string()));
        }
        if let Some(platform) = platform {
            params.push(("platform", platform.to_string()));
        }
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params("/images/create", &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(input_image)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageCreateCodes::Ok,
        404 => ImageCreateCodes::NotFound(resp.json()?),
        500 => ImageCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageInspectCodes {
    /// No error
    Ok(Image),
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_inspect(
    client: &Client,
    name: &str,
) -> Result<ImageInspectCodes, Error> {
    let url = format!("/images/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageInspectCodes::Ok(resp.json()?),
        404 => ImageInspectCodes::NotFound(resp.json()?),
        500 => ImageInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageHistoryCodes {
    /// List of image layers
    Ok(Vec<ImageHistory>),
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_history(
    client: &Client,
    name: &str,
) -> Result<ImageHistoryCodes, Error> {
    let url = format!("/images/{name}/history",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageHistoryCodes::Ok(resp.json()?),
        404 => ImageHistoryCodes::NotFound(resp.json()?),
        500 => ImageHistoryCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImagePushCodes {
    /// No error
    Ok,
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_push(
    client: &Client,
    name: &str,
    tag: Option<&str>,
    x_registry_auth: &str,
) -> Result<ImagePushCodes, Error> {
    let url = format!("/images/{name}/push",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());

    let mut resp = client.post(url)
        .headers(headers)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImagePushCodes::Ok,
        404 => ImagePushCodes::NotFound(resp.json()?),
        500 => ImagePushCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageTagCodes {
    /// No error
    Created,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// No such image
    NotFound(ErrorResponse),
    /// Conflict
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_tag(
    client: &Client,
    name: &str,
    repo: Option<&str>,
    tag: Option<&str>,
) -> Result<ImageTagCodes, Error> {
    let url = format!("/images/{name}/tag",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ImageTagCodes::Created,
        400 => ImageTagCodes::BadRequest(resp.json()?),
        404 => ImageTagCodes::NotFound(resp.json()?),
        409 => ImageTagCodes::Conflict(resp.json()?),
        500 => ImageTagCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageDeleteCodes {
    /// The image was deleted successfully
    Ok(Vec<ImageDeleteResponseItem>),
    /// No such image
    NotFound(ErrorResponse),
    /// Conflict
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
    noprune: Option<bool>,
) -> Result<ImageDeleteCodes, Error> {
    let url = format!("/images/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        if let Some(noprune) = noprune {
            params.push(("noprune", noprune.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageDeleteCodes::Ok(resp.json()?),
        404 => ImageDeleteCodes::NotFound(resp.json()?),
        409 => ImageDeleteCodes::Conflict(resp.json()?),
        500 => ImageDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageSearchCodes {
    /// No error
    Ok(Vec<ImageSearch>),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_search(
    client: &Client,
    term: &str,
    limit: Option<i64>,
    filters: Option<&str>,
) -> Result<ImageSearchCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(limit) = limit {
            params.push(("limit", limit.to_string()));
        }
        params.push(("term", term.to_string()));
        Url::parse_with_params("/images/search", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageSearchCodes::Ok(resp.json()?),
        500 => ImageSearchCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImagePruneCodes {
    /// No error
    Ok(ImagePrune),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn image_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<ImagePruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/images/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImagePruneCodes::Ok(resp.json()?),
        500 => ImagePruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemAuthCodes {
    /// An identity token was generated successfully.
    Ok(SystemAuth),
    /// No error
    NoContent,
    /// Server error
    ServerError(ErrorResponse),
}

pub fn system_auth(
    client: &Client,
    auth_config: &AuthConfig,
) -> Result<SystemAuthCodes, Error> {
    let mut resp = client.post("/auth")
        .json(auth_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemAuthCodes::Ok(resp.json()?),
        204 => SystemAuthCodes::NoContent,
        500 => SystemAuthCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemInfoCodes {
    /// No error
    Ok(SystemInfo),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn system_info(
    client: &Client,
) -> Result<SystemInfoCodes, Error> {
    let mut resp = client.get("/info")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemInfoCodes::Ok(resp.json()?),
        500 => SystemInfoCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemVersionCodes {
    /// no error
    Ok(SystemVersion),
    /// server error
    ServerError(ErrorResponse),
}

pub fn system_version(
    client: &Client,
) -> Result<SystemVersionCodes, Error> {
    let mut resp = client.get("/version")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemVersionCodes::Ok(resp.json()?),
        500 => SystemVersionCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemPingCodes {
    /// no error
    Ok(String),
    /// server error
    ServerError(ErrorResponse),
}

pub fn system_ping(
    client: &Client,
) -> Result<SystemPingCodes, Error> {
    let mut resp = client.get("/_ping")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemPingCodes::Ok(resp.json()?),
        500 => SystemPingCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageCommitCodes {
    /// no error
    Created(IdResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_commit(
    client: &Client,
    container_config: &ContainerConfig,
    container: Option<&str>,
    repo: Option<&str>,
    tag: Option<&str>,
    comment: Option<&str>,
    author: Option<&str>,
    pause: Option<bool>,
    changes: Option<&str>,
) -> Result<ImageCommitCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(author) = author {
            params.push(("author", author.to_string()));
        }
        if let Some(changes) = changes {
            params.push(("changes", changes.to_string()));
        }
        if let Some(comment) = comment {
            params.push(("comment", comment.to_string()));
        }
        if let Some(container) = container {
            params.push(("container", container.to_string()));
        }
        if let Some(pause) = pause {
            params.push(("pause", pause.to_string()));
        }
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params("/commit", &params)?
    };

    let mut resp = client.post(url)
        .json(container_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ImageCommitCodes::Created(resp.json()?),
        404 => ImageCommitCodes::NotFound(resp.json()?),
        500 => ImageCommitCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemEventsCodes {
    /// no error
    Ok(SystemEvents),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn system_events(
    client: &Client,
    since: Option<&str>,
    until: Option<&str>,
    filters: Option<&str>,
) -> Result<SystemEventsCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(until) = until {
            params.push(("until", until.to_string()));
        }
        Url::parse_with_params("/events", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemEventsCodes::Ok(resp.json()?),
        400 => SystemEventsCodes::BadRequest(resp.json()?),
        500 => SystemEventsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SystemDataUsageCodes {
    /// no error
    Ok(SystemDataUsage),
    /// server error
    ServerError(ErrorResponse),
}

pub fn system_data_usage(
    client: &Client,
) -> Result<SystemDataUsageCodes, Error> {
    let mut resp = client.get("/system/df")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemDataUsageCodes::Ok(resp.json()?),
        500 => SystemDataUsageCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageGetCodes {
    /// no error
    Ok((/* binary */)),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_get(
    client: &Client,
    name: &str,
) -> Result<ImageGetCodes, Error> {
    let url = format!("/images/{name}/get",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageGetCodes::Ok(resp.json()?),
        500 => ImageGetCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageGetAllCodes {
    /// no error
    Ok((/* binary */)),
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_get_all(
    client: &Client,
    names: Option<&[String]>,
) -> Result<ImageGetAllCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(names) = names {
            params.push(("names", names.to_vec().join(",")));
        }
        Url::parse_with_params("/images/get", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageGetAllCodes::Ok(resp.json()?),
        500 => ImageGetAllCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ImageLoadCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
}

pub fn image_load(
    client: &Client,
    images_tarball: (/* binary */),
    quiet: Option<bool>,
) -> Result<ImageLoadCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(quiet) = quiet {
            params.push(("quiet", quiet.to_string()));
        }
        Url::parse_with_params("/images/load", &params)?
    };

    let mut resp = client.post(url)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageLoadCodes::Ok,
        500 => ImageLoadCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ContainerExecCodes {
    /// no error
    Created(IdResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// container is paused
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn container_exec(
    client: &Client,
    exec_config: &ContainerExec,
    id: &str,
) -> Result<ContainerExecCodes, Error> {
    let url = format!("/containers/{id}/exec",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(exec_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ContainerExecCodes::Created(resp.json()?),
        404 => ContainerExecCodes::NotFound(resp.json()?),
        409 => ContainerExecCodes::Conflict(resp.json()?),
        500 => ContainerExecCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ExecStartCodes {
    /// No error
    Ok,
    /// No such exec instance
    NotFound(ErrorResponse),
    /// Container is stopped or paused
    Conflict(ErrorResponse),
}

pub fn exec_start(
    client: &Client,
    exec_start_config: &ExecStart,
    id: &str,
) -> Result<ExecStartCodes, Error> {
    let url = format!("/exec/{id}/start",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(exec_start_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ExecStartCodes::Ok,
        404 => ExecStartCodes::NotFound(resp.json()?),
        409 => ExecStartCodes::Conflict(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ExecResizeCodes {
    /// No error
    Created,
    /// No such exec instance
    NotFound(ErrorResponse),
}

pub fn exec_resize(
    client: &Client,
    id: &str,
    h: Option<i64>,
    w: Option<i64>,
) -> Result<ExecResizeCodes, Error> {
    let url = format!("/exec/{id}/resize",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(h) = h {
            params.push(("h", h.to_string()));
        }
        if let Some(w) = w {
            params.push(("w", w.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ExecResizeCodes::Created,
        404 => ExecResizeCodes::NotFound(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ExecInspectCodes {
    /// No error
    Ok(ExecInspect),
    /// No such exec instance
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn exec_inspect(
    client: &Client,
    id: &str,
) -> Result<ExecInspectCodes, Error> {
    let url = format!("/exec/{id}/json",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ExecInspectCodes::Ok(resp.json()?),
        404 => ExecInspectCodes::NotFound(resp.json()?),
        500 => ExecInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum VolumeListCodes {
    /// Summary volume data that matches the query
    Ok(VolumeList),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn volume_list(
    client: &Client,
    filters: Option<::serde_json::Value>,
) -> Result<VolumeListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/volumes", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumeListCodes::Ok(resp.json()?),
        500 => VolumeListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum VolumeCreateCodes {
    /// The volume was created successfully
    Created(Volume),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn volume_create(
    client: &Client,
    volume_config: &VolumeCreate,
) -> Result<VolumeCreateCodes, Error> {
    let mut resp = client.post("/volumes/create")
        .json(volume_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => VolumeCreateCodes::Created(resp.json()?),
        500 => VolumeCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum VolumeInspectCodes {
    /// No error
    Ok(Volume),
    /// No such volume
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn volume_inspect(
    client: &Client,
    name: &str,
) -> Result<VolumeInspectCodes, Error> {
    let url = format!("/volumes/{name}",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumeInspectCodes::Ok(resp.json()?),
        404 => VolumeInspectCodes::NotFound(resp.json()?),
        500 => VolumeInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum VolumeDeleteCodes {
    /// The volume was removed
    NoContent,
    /// No such volume or volume driver
    NotFound(ErrorResponse),
    /// Volume is in use and cannot be removed
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn volume_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
) -> Result<VolumeDeleteCodes, Error> {
    let url = format!("/volumes/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => VolumeDeleteCodes::NoContent,
        404 => VolumeDeleteCodes::NotFound(resp.json()?),
        409 => VolumeDeleteCodes::Conflict(resp.json()?),
        500 => VolumeDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum VolumePruneCodes {
    /// No error
    Ok(VolumePrune),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn volume_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<VolumePruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/volumes/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumePruneCodes::Ok(resp.json()?),
        500 => VolumePruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkListCodes {
    /// No error
    Ok(Vec<Network>),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<NetworkListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/networks", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkListCodes::Ok(resp.json()?),
        500 => NetworkListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkInspectCodes {
    /// No error
    Ok(Network),
    /// Network not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_inspect(
    client: &Client,
    id: &str,
    verbose: Option<bool>,
    scope: Option<&str>,
) -> Result<NetworkInspectCodes, Error> {
    let url = format!("/networks/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(scope) = scope {
            params.push(("scope", scope.to_string()));
        }
        if let Some(verbose) = verbose {
            params.push(("verbose", verbose.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkInspectCodes::Ok(resp.json()?),
        404 => NetworkInspectCodes::NotFound(resp.json()?),
        500 => NetworkInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkDeleteCodes {
    /// No error
    NoContent,
    /// operation not supported for pre-defined networks
    Forbidden(ErrorResponse),
    /// no such network
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_delete(
    client: &Client,
    id: &str,
) -> Result<NetworkDeleteCodes, Error> {
    let url = format!("/networks/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => NetworkDeleteCodes::NoContent,
        403 => NetworkDeleteCodes::Forbidden(resp.json()?),
        404 => NetworkDeleteCodes::NotFound(resp.json()?),
        500 => NetworkDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkCreateCodes {
    /// No error
    Created(NetworkCreateCreated),
    /// operation not supported for pre-defined networks
    Forbidden(ErrorResponse),
    /// plugin not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_create(
    client: &Client,
    network_config: &NetworkCreateNetworkConfig,
) -> Result<NetworkCreateCodes, Error> {
    let mut resp = client.post("/networks/create")
        .json(network_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => NetworkCreateCodes::Created(resp.json()?),
        403 => NetworkCreateCodes::Forbidden(resp.json()?),
        404 => NetworkCreateCodes::NotFound(resp.json()?),
        500 => NetworkCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkConnectCodes {
    /// No error
    Ok,
    /// Operation not supported for swarm scoped networks
    Forbidden(ErrorResponse),
    /// Network or container not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_connect(
    client: &Client,
    id: &str,
    container: &NetworkConnect,
) -> Result<NetworkConnectCodes, Error> {
    let url = format!("/networks/{id}/connect",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(container)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkConnectCodes::Ok,
        403 => NetworkConnectCodes::Forbidden(resp.json()?),
        404 => NetworkConnectCodes::NotFound(resp.json()?),
        500 => NetworkConnectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkDisconnectCodes {
    /// No error
    Ok,
    /// Operation not supported for swarm scoped networks
    Forbidden(ErrorResponse),
    /// Network or container not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_disconnect(
    client: &Client,
    id: &str,
    container: &NetworkDisconnect,
) -> Result<NetworkDisconnectCodes, Error> {
    let url = format!("/networks/{id}/disconnect",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(container)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkDisconnectCodes::Ok,
        403 => NetworkDisconnectCodes::Forbidden(resp.json()?),
        404 => NetworkDisconnectCodes::NotFound(resp.json()?),
        500 => NetworkDisconnectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NetworkPruneCodes {
    /// No error
    Ok(NetworkPrune),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn network_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<NetworkPruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/networks/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkPruneCodes::Ok(resp.json()?),
        500 => NetworkPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginListCodes {
    /// No error
    Ok(Vec<Plugin>),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn plugin_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<PluginListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/plugins", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginListCodes::Ok(resp.json()?),
        500 => PluginListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum GetPluginPrivilegesCodes {
    /// no error
    Ok(Vec<GetPluginPrivileges>),
    /// server error
    ServerError(ErrorResponse),
}

pub fn get_plugin_privileges(
    client: &Client,
    remote: &str,
) -> Result<GetPluginPrivilegesCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("remote", remote.to_string()));
        Url::parse_with_params("/plugins/privileges", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => GetPluginPrivilegesCodes::Ok(resp.json()?),
        500 => GetPluginPrivilegesCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginPullCodes {
    /// no error
    NoContent,
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_pull(
    client: &Client,
    remote: &str,
    name: Option<&str>,
    x_registry_auth: Option<&str>,
    body: &[GetPluginPrivileges],
) -> Result<PluginPullCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(name) = name {
            params.push(("name", name.to_string()));
        }
        params.push(("remote", remote.to_string()));
        Url::parse_with_params("/plugins/pull", &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginPullCodes::NoContent,
        500 => PluginPullCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginInspectCodes {
    /// no error
    Ok(Plugin),
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_inspect(
    client: &Client,
    name: &str,
) -> Result<PluginInspectCodes, Error> {
    let url = format!("/plugins/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginInspectCodes::Ok(resp.json()?),
        404 => PluginInspectCodes::NotFound(resp.json()?),
        500 => PluginInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginDeleteCodes {
    /// no error
    Ok(Plugin),
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
) -> Result<PluginDeleteCodes, Error> {
    let url = format!("/plugins/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginDeleteCodes::Ok(resp.json()?),
        404 => PluginDeleteCodes::NotFound(resp.json()?),
        500 => PluginDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginEnableCodes {
    /// no error
    Ok,
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_enable(
    client: &Client,
    name: &str,
    timeout: Option<i64>,
) -> Result<PluginEnableCodes, Error> {
    let url = format!("/plugins/{name}/enable",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(timeout) = timeout {
            params.push(("timeout", timeout.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginEnableCodes::Ok,
        404 => PluginEnableCodes::NotFound(resp.json()?),
        500 => PluginEnableCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginDisableCodes {
    /// no error
    Ok,
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_disable(
    client: &Client,
    name: &str,
) -> Result<PluginDisableCodes, Error> {
    let url = format!("/plugins/{name}/disable",
        name=name,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginDisableCodes::Ok,
        404 => PluginDisableCodes::NotFound(resp.json()?),
        500 => PluginDisableCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginUpgradeCodes {
    /// no error
    NoContent,
    /// plugin not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_upgrade(
    client: &Client,
    name: &str,
    remote: &str,
    x_registry_auth: Option<&str>,
    body: &[GetPluginPrivileges],
) -> Result<PluginUpgradeCodes, Error> {
    let url = format!("/plugins/{name}/upgrade",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("remote", remote.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginUpgradeCodes::NoContent,
        404 => PluginUpgradeCodes::NotFound(resp.json()?),
        500 => PluginUpgradeCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginCreateCodes {
    /// no error
    NoContent,
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_create(
    client: &Client,
    name: &str,
    tar_context: (/* binary */),
) -> Result<PluginCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("name", name.to_string()));
        Url::parse_with_params("/plugins/create", &params)?
    };

    let mut resp = client.post(url)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginCreateCodes::NoContent,
        500 => PluginCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginPushCodes {
    /// no error
    Ok,
    /// plugin not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn plugin_push(
    client: &Client,
    name: &str,
) -> Result<PluginPushCodes, Error> {
    let url = format!("/plugins/{name}/push",
        name=name,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginPushCodes::Ok,
        404 => PluginPushCodes::NotFound(resp.json()?),
        500 => PluginPushCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum PluginSetCodes {
    /// No error
    NoContent,
    /// Plugin not installed
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn plugin_set(
    client: &Client,
    name: &str,
    body: &[String],
) -> Result<PluginSetCodes, Error> {
    let url = format!("/plugins/{name}/set",
        name=name,
    );

    let mut resp = client.post(&url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginSetCodes::NoContent,
        404 => PluginSetCodes::NotFound(resp.json()?),
        500 => PluginSetCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NodeListCodes {
    /// no error
    Ok(Vec<Node>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn node_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<NodeListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/nodes", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeListCodes::Ok(resp.json()?),
        500 => NodeListCodes::ServerError(resp.json()?),
        503 => NodeListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NodeInspectCodes {
    /// no error
    Ok(Node),
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn node_inspect(
    client: &Client,
    id: &str,
) -> Result<NodeInspectCodes, Error> {
    let url = format!("/nodes/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeInspectCodes::Ok(resp.json()?),
        404 => NodeInspectCodes::NotFound(resp.json()?),
        500 => NodeInspectCodes::ServerError(resp.json()?),
        503 => NodeInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NodeDeleteCodes {
    /// no error
    Ok,
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn node_delete(
    client: &Client,
    id: &str,
    force: Option<bool>,
) -> Result<NodeDeleteCodes, Error> {
    let url = format!("/nodes/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeDeleteCodes::Ok,
        404 => NodeDeleteCodes::NotFound(resp.json()?),
        500 => NodeDeleteCodes::ServerError(resp.json()?),
        503 => NodeDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum NodeUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn node_update(
    client: &Client,
    id: &str,
    body: &NodeSpec,
    version: i64,
) -> Result<NodeUpdateCodes, Error> {
    let url = format!("/nodes/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeUpdateCodes::Ok,
        400 => NodeUpdateCodes::BadRequest(resp.json()?),
        404 => NodeUpdateCodes::NotFound(resp.json()?),
        500 => NodeUpdateCodes::ServerError(resp.json()?),
        503 => NodeUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmInspectCodes {
    /// no error
    Ok(Swarm),
    /// no such swarm
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_inspect(
    client: &Client,
) -> Result<SwarmInspectCodes, Error> {
    let mut resp = client.get("/swarm")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmInspectCodes::Ok(resp.json()?),
        404 => SwarmInspectCodes::NotFound(resp.json()?),
        500 => SwarmInspectCodes::ServerError(resp.json()?),
        503 => SwarmInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmInitCodes {
    /// no error
    Ok(String),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is already part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_init(
    client: &Client,
    body: &SwarmInit,
) -> Result<SwarmInitCodes, Error> {
    let mut resp = client.post("/swarm/init")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmInitCodes::Ok(resp.json()?),
        400 => SwarmInitCodes::BadRequest(resp.json()?),
        500 => SwarmInitCodes::ServerError(resp.json()?),
        503 => SwarmInitCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmJoinCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is already part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_join(
    client: &Client,
    body: &SwarmJoin,
) -> Result<SwarmJoinCodes, Error> {
    let mut resp = client.post("/swarm/join")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmJoinCodes::Ok,
        400 => SwarmJoinCodes::BadRequest(resp.json()?),
        500 => SwarmJoinCodes::ServerError(resp.json()?),
        503 => SwarmJoinCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmLeaveCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_leave(
    client: &Client,
    force: Option<bool>,
) -> Result<SwarmLeaveCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params("/swarm/leave", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmLeaveCodes::Ok,
        500 => SwarmLeaveCodes::ServerError(resp.json()?),
        503 => SwarmLeaveCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_update(
    client: &Client,
    body: &SwarmSpec,
    version: i64,
    rotate_worker_token: Option<bool>,
    rotate_manager_token: Option<bool>,
    rotate_manager_unlock_key: Option<bool>,
) -> Result<SwarmUpdateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(4);
        if let Some(rotate_manager_token) = rotate_manager_token {
            params.push(("rotate_manager_token", rotate_manager_token.to_string()));
        }
        if let Some(rotate_manager_unlock_key) = rotate_manager_unlock_key {
            params.push(("rotate_manager_unlock_key", rotate_manager_unlock_key.to_string()));
        }
        if let Some(rotate_worker_token) = rotate_worker_token {
            params.push(("rotate_worker_token", rotate_worker_token.to_string()));
        }
        params.push(("version", version.to_string()));
        Url::parse_with_params("/swarm/update", &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUpdateCodes::Ok,
        400 => SwarmUpdateCodes::BadRequest(resp.json()?),
        500 => SwarmUpdateCodes::ServerError(resp.json()?),
        503 => SwarmUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmUnlockkeyCodes {
    /// no error
    Ok(SwarmUnlockkey),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_unlockkey(
    client: &Client,
) -> Result<SwarmUnlockkeyCodes, Error> {
    let mut resp = client.get("/swarm/unlockkey")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUnlockkeyCodes::Ok(resp.json()?),
        500 => SwarmUnlockkeyCodes::ServerError(resp.json()?),
        503 => SwarmUnlockkeyCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SwarmUnlockCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn swarm_unlock(
    client: &Client,
    body: &SwarmUnlockkey,
) -> Result<SwarmUnlockCodes, Error> {
    let mut resp = client.post("/swarm/unlock")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUnlockCodes::Ok,
        500 => SwarmUnlockCodes::ServerError(resp.json()?),
        503 => SwarmUnlockCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceListCodes {
    /// no error
    Ok(Vec<Service>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<ServiceListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/services", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceListCodes::Ok(resp.json()?),
        500 => ServiceListCodes::ServerError(resp.json()?),
        503 => ServiceListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceCreateCodes {
    /// no error
    Created(ServiceCreate),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// network is not eligible for services
    Forbidden(ErrorResponse),
    /// name conflicts with an existing service
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_create(
    client: &Client,
    body: &ServiceSpec,
    x_registry_auth: Option<&str>,
) -> Result<ServiceCreateCodes, Error> {
    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post("/services/create")
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ServiceCreateCodes::Created(resp.json()?),
        400 => ServiceCreateCodes::BadRequest(resp.json()?),
        403 => ServiceCreateCodes::Forbidden(resp.json()?),
        409 => ServiceCreateCodes::Conflict(resp.json()?),
        500 => ServiceCreateCodes::ServerError(resp.json()?),
        503 => ServiceCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceInspectCodes {
    /// no error
    Ok(Service),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_inspect(
    client: &Client,
    id: &str,
    insert_defaults: Option<bool>,
) -> Result<ServiceInspectCodes, Error> {
    let url = format!("/services/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(insert_defaults) = insert_defaults {
            params.push(("insert_defaults", insert_defaults.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceInspectCodes::Ok(resp.json()?),
        404 => ServiceInspectCodes::NotFound(resp.json()?),
        500 => ServiceInspectCodes::ServerError(resp.json()?),
        503 => ServiceInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceDeleteCodes {
    /// no error
    Ok,
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_delete(
    client: &Client,
    id: &str,
) -> Result<ServiceDeleteCodes, Error> {
    let url = format!("/services/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceDeleteCodes::Ok,
        404 => ServiceDeleteCodes::NotFound(resp.json()?),
        500 => ServiceDeleteCodes::ServerError(resp.json()?),
        503 => ServiceDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceUpdateCodes {
    /// no error
    Ok(ServiceUpdateResponse),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_update(
    client: &Client,
    id: &str,
    body: &ServiceSpec,
    version: i64,
    registry_auth_from: Option<&str>,
    rollback: Option<&str>,
    x_registry_auth: Option<&str>,
) -> Result<ServiceUpdateCodes, Error> {
    let url = format!("/services/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(registry_auth_from) = registry_auth_from {
            params.push(("registry_auth_from", registry_auth_from.to_string()));
        }
        if let Some(rollback) = rollback {
            params.push(("rollback", rollback.to_string()));
        }
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceUpdateCodes::Ok(resp.json()?),
        400 => ServiceUpdateCodes::BadRequest(resp.json()?),
        404 => ServiceUpdateCodes::NotFound(resp.json()?),
        500 => ServiceUpdateCodes::ServerError(resp.json()?),
        503 => ServiceUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ServiceLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn service_logs(
    client: &Client,
    id: &str,
    details: Option<bool>,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ServiceLogsCodes, Error> {
    let url = format!("/services/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(details) = details {
            params.push(("details", details.to_string()));
        }
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ServiceLogsCodes::SwitchingProtocols(resp.json()?),
        200 => ServiceLogsCodes::Ok(resp.json()?),
        404 => ServiceLogsCodes::NotFound(resp.json()?),
        500 => ServiceLogsCodes::ServerError(resp.json()?),
        503 => ServiceLogsCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum TaskListCodes {
    /// no error
    Ok(Vec<Task>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn task_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<TaskListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/tasks", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => TaskListCodes::Ok(resp.json()?),
        500 => TaskListCodes::ServerError(resp.json()?),
        503 => TaskListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum TaskInspectCodes {
    /// no error
    Ok(Task),
    /// no such task
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn task_inspect(
    client: &Client,
    id: &str,
) -> Result<TaskInspectCodes, Error> {
    let url = format!("/tasks/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => TaskInspectCodes::Ok(resp.json()?),
        404 => TaskInspectCodes::NotFound(resp.json()?),
        500 => TaskInspectCodes::ServerError(resp.json()?),
        503 => TaskInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum TaskLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such task
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn task_logs(
    client: &Client,
    id: &str,
    details: Option<bool>,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<TaskLogsCodes, Error> {
    let url = format!("/tasks/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(details) = details {
            params.push(("details", details.to_string()));
        }
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => TaskLogsCodes::SwitchingProtocols(resp.json()?),
        200 => TaskLogsCodes::Ok(resp.json()?),
        404 => TaskLogsCodes::NotFound(resp.json()?),
        500 => TaskLogsCodes::ServerError(resp.json()?),
        503 => TaskLogsCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SecretListCodes {
    /// no error
    Ok(Vec<Secret>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn secret_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<SecretListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/secrets", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretListCodes::Ok(resp.json()?),
        500 => SecretListCodes::ServerError(resp.json()?),
        503 => SecretListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SecretCreateCodes {
    /// no error
    Created(IdResponse),
    /// name conflicts with an existing object
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn secret_create(
    client: &Client,
    body: &SecretSpec,
) -> Result<SecretCreateCodes, Error> {
    let mut resp = client.post("/secrets/create")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => SecretCreateCodes::Created(resp.json()?),
        409 => SecretCreateCodes::Conflict(resp.json()?),
        500 => SecretCreateCodes::ServerError(resp.json()?),
        503 => SecretCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SecretInspectCodes {
    /// no error
    Ok(Secret),
    /// secret not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn secret_inspect(
    client: &Client,
    id: &str,
) -> Result<SecretInspectCodes, Error> {
    let url = format!("/secrets/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretInspectCodes::Ok(resp.json()?),
        404 => SecretInspectCodes::NotFound(resp.json()?),
        500 => SecretInspectCodes::ServerError(resp.json()?),
        503 => SecretInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SecretDeleteCodes {
    /// no error
    NoContent,
    /// secret not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn secret_delete(
    client: &Client,
    id: &str,
) -> Result<SecretDeleteCodes, Error> {
    let url = format!("/secrets/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => SecretDeleteCodes::NoContent,
        404 => SecretDeleteCodes::NotFound(resp.json()?),
        500 => SecretDeleteCodes::ServerError(resp.json()?),
        503 => SecretDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SecretUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such secret
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn secret_update(
    client: &Client,
    id: &str,
    body: &SecretSpec,
    version: i64,
) -> Result<SecretUpdateCodes, Error> {
    let url = format!("/secrets/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretUpdateCodes::Ok,
        400 => SecretUpdateCodes::BadRequest(resp.json()?),
        404 => SecretUpdateCodes::NotFound(resp.json()?),
        500 => SecretUpdateCodes::ServerError(resp.json()?),
        503 => SecretUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ConfigListCodes {
    /// no error
    Ok(Vec<Config>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn config_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<ConfigListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/configs", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigListCodes::Ok(resp.json()?),
        500 => ConfigListCodes::ServerError(resp.json()?),
        503 => ConfigListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ConfigCreateCodes {
    /// no error
    Created(IdResponse),
    /// name conflicts with an existing object
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn config_create(
    client: &Client,
    body: &ConfigSpec,
) -> Result<ConfigCreateCodes, Error> {
    let mut resp = client.post("/configs/create")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ConfigCreateCodes::Created(resp.json()?),
        409 => ConfigCreateCodes::Conflict(resp.json()?),
        500 => ConfigCreateCodes::ServerError(resp.json()?),
        503 => ConfigCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ConfigInspectCodes {
    /// no error
    Ok(Config),
    /// config not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn config_inspect(
    client: &Client,
    id: &str,
) -> Result<ConfigInspectCodes, Error> {
    let url = format!("/configs/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigInspectCodes::Ok(resp.json()?),
        404 => ConfigInspectCodes::NotFound(resp.json()?),
        500 => ConfigInspectCodes::ServerError(resp.json()?),
        503 => ConfigInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ConfigDeleteCodes {
    /// no error
    NoContent,
    /// config not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn config_delete(
    client: &Client,
    id: &str,
) -> Result<ConfigDeleteCodes, Error> {
    let url = format!("/configs/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ConfigDeleteCodes::NoContent,
        404 => ConfigDeleteCodes::NotFound(resp.json()?),
        500 => ConfigDeleteCodes::ServerError(resp.json()?),
        503 => ConfigDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum ConfigUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such config
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

pub fn config_update(
    client: &Client,
    id: &str,
    body: &ConfigSpec,
    version: i64,
) -> Result<ConfigUpdateCodes, Error> {
    let url = format!("/configs/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigUpdateCodes::Ok,
        400 => ConfigUpdateCodes::BadRequest(resp.json()?),
        404 => ConfigUpdateCodes::NotFound(resp.json()?),
        500 => ConfigUpdateCodes::ServerError(resp.json()?),
        503 => ConfigUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum DistributionInspectCodes {
    /// descriptor and platform information
    Ok(DistributionInspect),
    /// Failed authentication or no image found
    Unauthorised(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

pub fn distribution_inspect(
    client: &Client,
    name: &str,
) -> Result<DistributionInspectCodes, Error> {
    let url = format!("/distribution/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => DistributionInspectCodes::Ok(resp.json()?),
        401 => DistributionInspectCodes::Unauthorised(resp.json()?),
        500 => DistributionInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
pub enum SessionCodes {
    /// no error, hijacking successful
    SwitchingProtocols,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

pub fn session(
    client: &Client,
) -> Result<SessionCodes, Error> {
    let mut resp = client.post("/session")
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => SessionCodes::SwitchingProtocols,
        400 => SessionCodes::BadRequest(resp.json()?),
        500 => SessionCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

