// generated by swagger-codegen-rs
use failure::Error;
use reqwest::Client;
use reqwest::header::Headers;
use reqwest::Url;
#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Address {
    #[serde(rename = "Addr")]
    addr: String,
    #[serde(rename = "PrefixLen")]
    prefix_len: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct AuthConfig {
    #[serde(rename = "username")]
    username: String,
    #[serde(rename = "password")]
    password: String,
    #[serde(rename = "email")]
    email: String,
    #[serde(rename = "serveraddress")]
    serveraddress: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct BuildInfo {
    #[serde(rename = "id")]
    id: String,
    #[serde(rename = "stream")]
    stream: String,
    #[serde(rename = "error")]
    error: String,
    #[serde(rename = "errorDetail")]
    error_detail: ErrorDetail,
    #[serde(rename = "status")]
    status: String,
    #[serde(rename = "progress")]
    progress: String,
    #[serde(rename = "progressDetail")]
    progress_detail: ProgressDetail,
    #[serde(rename = "aux")]
    aux: ImageID,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct BuildPrune {
    #[serde(rename = "SpaceReclaimed")]
    space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ClusterInfo {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: SwarmSpec,
    #[serde(rename = "TLSInfo")]
    tls_info: TLSInfo,
    #[serde(rename = "RootRotationInProgress")]
    root_rotation_in_progress: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Commit {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Expected")]
    expected: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Config {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: ConfigSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ConfigSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Data")]
    data: String,
    #[serde(rename = "Templating")]
    templating: Driver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerChanges {
    #[serde(rename = "Path")]
    path: String,
    #[serde(rename = "Kind")]
    kind: u8,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerConfig {
    #[serde(rename = "Hostname")]
    hostname: String,
    #[serde(rename = "Domainname")]
    domainname: String,
    #[serde(rename = "User")]
    user: String,
    #[serde(rename = "AttachStdin")]
    attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    attach_stderr: bool,
    #[serde(rename = "ExposedPorts")]
    exposed_ports: ::serde_json::Value,
    #[serde(rename = "Tty")]
    tty: bool,
    #[serde(rename = "OpenStdin")]
    open_stdin: bool,
    #[serde(rename = "StdinOnce")]
    stdin_once: bool,
    #[serde(rename = "Env")]
    env: Vec<String>,
    #[serde(rename = "Cmd")]
    cmd: Vec<String>,
    #[serde(rename = "Healthcheck")]
    healthcheck: HealthConfig,
    #[serde(rename = "ArgsEscaped")]
    args_escaped: bool,
    #[serde(rename = "Image")]
    image: String,
    #[serde(rename = "Volumes")]
    volumes: ::serde_json::Value,
    #[serde(rename = "WorkingDir")]
    working_dir: String,
    #[serde(rename = "Entrypoint")]
    entrypoint: Vec<String>,
    #[serde(rename = "NetworkDisabled")]
    network_disabled: bool,
    #[serde(rename = "MacAddress")]
    mac_address: String,
    #[serde(rename = "OnBuild")]
    on_build: Vec<String>,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "StopSignal")]
    stop_signal: String,
    #[serde(rename = "StopTimeout")]
    stop_timeout: i64,
    #[serde(rename = "Shell")]
    shell: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateBody {
    #[serde(rename = "Hostname")]
    hostname: String,
    #[serde(rename = "Domainname")]
    domainname: String,
    #[serde(rename = "User")]
    user: String,
    #[serde(rename = "AttachStdin")]
    attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    attach_stderr: bool,
    #[serde(rename = "ExposedPorts")]
    exposed_ports: ::serde_json::Value,
    #[serde(rename = "Tty")]
    tty: bool,
    #[serde(rename = "OpenStdin")]
    open_stdin: bool,
    #[serde(rename = "StdinOnce")]
    stdin_once: bool,
    #[serde(rename = "Env")]
    env: Vec<String>,
    #[serde(rename = "Cmd")]
    cmd: Vec<String>,
    #[serde(rename = "Healthcheck")]
    healthcheck: HealthConfig,
    #[serde(rename = "ArgsEscaped")]
    args_escaped: bool,
    #[serde(rename = "Image")]
    image: String,
    #[serde(rename = "Volumes")]
    volumes: ::serde_json::Value,
    #[serde(rename = "WorkingDir")]
    working_dir: String,
    #[serde(rename = "Entrypoint")]
    entrypoint: Vec<String>,
    #[serde(rename = "NetworkDisabled")]
    network_disabled: bool,
    #[serde(rename = "MacAddress")]
    mac_address: String,
    #[serde(rename = "OnBuild")]
    on_build: Vec<String>,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "StopSignal")]
    stop_signal: String,
    #[serde(rename = "StopTimeout")]
    stop_timeout: i64,
    #[serde(rename = "Shell")]
    shell: Vec<String>,
    #[serde(rename = "HostConfig")]
    host_config: HostConfig,
    #[serde(rename = "NetworkingConfig")]
    networking_config: ContainerCreateNetworkingConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateCreated {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Warnings")]
    warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateHostConfigBlkioWeightDevice {
    #[serde(rename = "Path")]
    path: String,
    #[serde(rename = "Weight")]
    weight: u64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerCreateHostConfigIsolation {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "process")]
    Process,
    #[serde(rename = "hyperv")]
    Hyperv,
}

impl ToString for ContainerCreateHostConfigIsolation {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigIsolation::Default => "default",
            ContainerCreateHostConfigIsolation::Process => "process",
            ContainerCreateHostConfigIsolation::Hyperv => "hyperv",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateHostConfigLogConfig {
    #[serde(rename = "Type")]
    type_: ContainerCreateHostConfigLogConfigType,
    #[serde(rename = "Config")]
    config: ::serde_json::Value,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerCreateHostConfigLogConfigType {
    #[serde(rename = "json-file")]
    Jsonfile,
    #[serde(rename = "syslog")]
    Syslog,
    #[serde(rename = "journald")]
    Journald,
    #[serde(rename = "gelf")]
    Gelf,
    #[serde(rename = "fluentd")]
    Fluentd,
    #[serde(rename = "awslogs")]
    Awslogs,
    #[serde(rename = "splunk")]
    Splunk,
    #[serde(rename = "etwlogs")]
    Etwlogs,
    #[serde(rename = "none")]
    None,
}

impl ToString for ContainerCreateHostConfigLogConfigType {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigLogConfigType::Jsonfile => "json-file",
            ContainerCreateHostConfigLogConfigType::Syslog => "syslog",
            ContainerCreateHostConfigLogConfigType::Journald => "journald",
            ContainerCreateHostConfigLogConfigType::Gelf => "gelf",
            ContainerCreateHostConfigLogConfigType::Fluentd => "fluentd",
            ContainerCreateHostConfigLogConfigType::Awslogs => "awslogs",
            ContainerCreateHostConfigLogConfigType::Splunk => "splunk",
            ContainerCreateHostConfigLogConfigType::Etwlogs => "etwlogs",
            ContainerCreateHostConfigLogConfigType::None => "none",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerCreateHostConfigRestartPolicyName {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "always")]
    Always,
    #[serde(rename = "unless-stopped")]
    Unlessstopped,
    #[serde(rename = "on-failure")]
    Onfailure,
}

impl ToString for ContainerCreateHostConfigRestartPolicyName {
    fn to_string(&self) -> String {
        match self {
            ContainerCreateHostConfigRestartPolicyName::Empty => "",
            ContainerCreateHostConfigRestartPolicyName::Always => "always",
            ContainerCreateHostConfigRestartPolicyName::Unlessstopped => "unless-stopped",
            ContainerCreateHostConfigRestartPolicyName::Onfailure => "on-failure",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateHostConfigUlimits {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Soft")]
    soft: i64,
    #[serde(rename = "Hard")]
    hard: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerCreateNetworkingConfig {
    #[serde(rename = "EndpointsConfig")]
    endpoints_config: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerExec {
    #[serde(rename = "AttachStdin")]
    attach_stdin: bool,
    #[serde(rename = "AttachStdout")]
    attach_stdout: bool,
    #[serde(rename = "AttachStderr")]
    attach_stderr: bool,
    #[serde(rename = "DetachKeys")]
    detach_keys: String,
    #[serde(rename = "Tty")]
    tty: bool,
    #[serde(rename = "Env")]
    env: Vec<String>,
    #[serde(rename = "Cmd")]
    cmd: Vec<String>,
    #[serde(rename = "Privileged")]
    privileged: bool,
    #[serde(rename = "User")]
    user: String,
    #[serde(rename = "WorkingDir")]
    working_dir: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerInspect {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Created")]
    created: String,
    #[serde(rename = "Path")]
    path: String,
    #[serde(rename = "Args")]
    args: Vec<String>,
    #[serde(rename = "State")]
    state: ContainerInspectState,
    #[serde(rename = "Image")]
    image: String,
    #[serde(rename = "ResolvConfPath")]
    resolv_conf_path: String,
    #[serde(rename = "HostnamePath")]
    hostname_path: String,
    #[serde(rename = "HostsPath")]
    hosts_path: String,
    #[serde(rename = "LogPath")]
    log_path: String,
    #[serde(rename = "Node")]
    node: ::serde_json::Value,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "RestartCount")]
    restart_count: i64,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "MountLabel")]
    mount_label: String,
    #[serde(rename = "ProcessLabel")]
    process_label: String,
    #[serde(rename = "AppArmorProfile")]
    app_armor_profile: String,
    #[serde(rename = "ExecIDs")]
    exec_i_ds: Vec<String>,
    #[serde(rename = "HostConfig")]
    host_config: HostConfig,
    #[serde(rename = "GraphDriver")]
    graph_driver: GraphDriverData,
    #[serde(rename = "SizeRw")]
    size_rw: i64,
    #[serde(rename = "SizeRootFs")]
    size_root_fs: i64,
    #[serde(rename = "Mounts")]
    mounts: Vec<MountPoint>,
    #[serde(rename = "Config")]
    config: ContainerConfig,
    #[serde(rename = "NetworkSettings")]
    network_settings: NetworkSettings,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerInspectState {
    #[serde(rename = "Status")]
    status: ContainerInspectStateStatus,
    #[serde(rename = "Running")]
    running: bool,
    #[serde(rename = "Paused")]
    paused: bool,
    #[serde(rename = "Restarting")]
    restarting: bool,
    #[serde(rename = "OOMKilled")]
    oom_killed: bool,
    #[serde(rename = "Dead")]
    dead: bool,
    #[serde(rename = "Pid")]
    pid: i64,
    #[serde(rename = "ExitCode")]
    exit_code: i64,
    #[serde(rename = "Error")]
    error: String,
    #[serde(rename = "StartedAt")]
    started_at: String,
    #[serde(rename = "FinishedAt")]
    finished_at: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerInspectStateStatus {
    #[serde(rename = "created")]
    Created,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "paused")]
    Paused,
    #[serde(rename = "restarting")]
    Restarting,
    #[serde(rename = "removing")]
    Removing,
    #[serde(rename = "exited")]
    Exited,
    #[serde(rename = "dead")]
    Dead,
}

impl ToString for ContainerInspectStateStatus {
    fn to_string(&self) -> String {
        match self {
            ContainerInspectStateStatus::Created => "created",
            ContainerInspectStateStatus::Running => "running",
            ContainerInspectStateStatus::Paused => "paused",
            ContainerInspectStateStatus::Restarting => "restarting",
            ContainerInspectStateStatus::Removing => "removing",
            ContainerInspectStateStatus::Exited => "exited",
            ContainerInspectStateStatus::Dead => "dead",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerList {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Names")]
    names: Vec<String>,
    #[serde(rename = "Image")]
    image: String,
    #[serde(rename = "ImageID")]
    image_id: String,
    #[serde(rename = "Command")]
    command: String,
    #[serde(rename = "Created")]
    created: i64,
    #[serde(rename = "Ports")]
    ports: Vec<Port>,
    #[serde(rename = "SizeRw")]
    size_rw: i64,
    #[serde(rename = "SizeRootFs")]
    size_root_fs: i64,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "State")]
    state: String,
    #[serde(rename = "Status")]
    status: String,
    #[serde(rename = "HostConfig")]
    host_config: ContainerListHostConfig,
    #[serde(rename = "NetworkSettings")]
    network_settings: ContainerListNetworkSettings,
    #[serde(rename = "Mounts")]
    mounts: Vec<Mount>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListHostConfig {
    #[serde(rename = "NetworkMode")]
    network_mode: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListMountsBindOptions {
    #[serde(rename = "Propagation")]
    propagation: ContainerListMountsBindOptionsPropagation,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerListMountsBindOptionsPropagation {
    #[serde(rename = "private")]
    Private,
    #[serde(rename = "rprivate")]
    Rprivate,
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "rshared")]
    Rshared,
    #[serde(rename = "slave")]
    Slave,
    #[serde(rename = "rslave")]
    Rslave,
}

impl ToString for ContainerListMountsBindOptionsPropagation {
    fn to_string(&self) -> String {
        match self {
            ContainerListMountsBindOptionsPropagation::Private => "private",
            ContainerListMountsBindOptionsPropagation::Rprivate => "rprivate",
            ContainerListMountsBindOptionsPropagation::Shared => "shared",
            ContainerListMountsBindOptionsPropagation::Rshared => "rshared",
            ContainerListMountsBindOptionsPropagation::Slave => "slave",
            ContainerListMountsBindOptionsPropagation::Rslave => "rslave",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListMountsTmpfsOptions {
    #[serde(rename = "SizeBytes")]
    size_bytes: i64,
    #[serde(rename = "Mode")]
    mode: i64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerListMountsType {
    #[serde(rename = "bind")]
    Bind,
    #[serde(rename = "volume")]
    Volume,
    #[serde(rename = "tmpfs")]
    Tmpfs,
}

impl ToString for ContainerListMountsType {
    fn to_string(&self) -> String {
        match self {
            ContainerListMountsType::Bind => "bind",
            ContainerListMountsType::Volume => "volume",
            ContainerListMountsType::Tmpfs => "tmpfs",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListMountsVolumeOptions {
    #[serde(rename = "NoCopy")]
    no_copy: bool,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "DriverConfig")]
    driver_config: ContainerListMountsVolumeOptionsDriverConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListMountsVolumeOptionsDriverConfig {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerListNetworkSettings {
    #[serde(rename = "Networks")]
    networks: ::serde_json::Value,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ContainerListPortsType {
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
    #[serde(rename = "sctp")]
    Sctp,
}

impl ToString for ContainerListPortsType {
    fn to_string(&self) -> String {
        match self {
            ContainerListPortsType::Tcp => "tcp",
            ContainerListPortsType::Udp => "udp",
            ContainerListPortsType::Sctp => "sctp",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerPrune {
    #[serde(rename = "ContainersDeleted")]
    containers_deleted: Vec<String>,
    #[serde(rename = "SpaceReclaimed")]
    space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerTop {
    #[serde(rename = "Titles")]
    titles: Vec<String>,
    #[serde(rename = "Processes")]
    processes: Vec<Vec<String>>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerUpdateOk {
    #[serde(rename = "Warnings")]
    warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerUpdateUpdate {
    #[serde(rename = "CpuShares")]
    cpu_shares: i64,
    #[serde(rename = "Memory")]
    memory: i64,
    #[serde(rename = "CgroupParent")]
    cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    cpuset_mems: String,
    #[serde(rename = "Devices")]
    devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    oom_kill_disable: bool,
    #[serde(rename = "Init")]
    init: bool,
    #[serde(rename = "PidsLimit")]
    pids_limit: i64,
    #[serde(rename = "Ulimits")]
    ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    io_maximum_bandwidth: i64,
    #[serde(rename = "RestartPolicy")]
    restart_policy: RestartPolicy,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerWait {
    #[serde(rename = "StatusCode")]
    status_code: i64,
    #[serde(rename = "Error")]
    error: ContainerWaitError,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ContainerWaitError {
    #[serde(rename = "Message")]
    message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct CreateImageInfo {
    #[serde(rename = "id")]
    id: String,
    #[serde(rename = "error")]
    error: String,
    #[serde(rename = "status")]
    status: String,
    #[serde(rename = "progress")]
    progress: String,
    #[serde(rename = "progressDetail")]
    progress_detail: ProgressDetail,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct DeviceMapping {
    #[serde(rename = "PathOnHost")]
    path_on_host: String,
    #[serde(rename = "PathInContainer")]
    path_in_container: String,
    #[serde(rename = "CgroupPermissions")]
    cgroup_permissions: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct DistributionInspect {
    #[serde(rename = "Descriptor")]
    descriptor: DistributionInspectDescriptor,
    #[serde(rename = "Platforms")]
    platforms: Vec<DistributionInspectPlatforms>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct DistributionInspectDescriptor {
    #[serde(rename = "MediaType")]
    media_type: String,
    #[serde(rename = "Size")]
    size: i64,
    #[serde(rename = "Digest")]
    digest: String,
    #[serde(rename = "URLs")]
    ur_ls: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct DistributionInspectPlatforms {
    #[serde(rename = "Architecture")]
    architecture: String,
    #[serde(rename = "OS")]
    os: String,
    #[serde(rename = "OSVersion")]
    os_version: String,
    #[serde(rename = "OSFeatures")]
    os_features: Vec<String>,
    #[serde(rename = "Variant")]
    variant: String,
    #[serde(rename = "Features")]
    features: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Driver {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct EndpointIPAMConfig {
    #[serde(rename = "IPv4Address")]
    i_pv4_address: String,
    #[serde(rename = "IPv6Address")]
    i_pv6_address: String,
    #[serde(rename = "LinkLocalIPs")]
    link_local_i_ps: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct EndpointPortConfig {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Protocol")]
    protocol: ContainerListPortsType,
    #[serde(rename = "TargetPort")]
    target_port: i64,
    #[serde(rename = "PublishedPort")]
    published_port: i64,
    #[serde(rename = "PublishMode")]
    publish_mode: ServiceListSpecEndpointSpecPortsPublishMode,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct EndpointSettings {
    #[serde(rename = "IPAMConfig")]
    ipam_config: EndpointIPAMConfig,
    #[serde(rename = "Links")]
    links: Vec<String>,
    #[serde(rename = "Aliases")]
    aliases: Vec<String>,
    #[serde(rename = "NetworkID")]
    network_id: String,
    #[serde(rename = "EndpointID")]
    endpoint_id: String,
    #[serde(rename = "Gateway")]
    gateway: String,
    #[serde(rename = "IPAddress")]
    ip_address: String,
    #[serde(rename = "IPPrefixLen")]
    ip_prefix_len: i64,
    #[serde(rename = "IPv6Gateway")]
    i_pv6_gateway: String,
    #[serde(rename = "GlobalIPv6Address")]
    global_i_pv6_address: String,
    #[serde(rename = "GlobalIPv6PrefixLen")]
    global_i_pv6_prefix_len: i64,
    #[serde(rename = "MacAddress")]
    mac_address: String,
    #[serde(rename = "DriverOpts")]
    driver_opts: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct EndpointSpec {
    #[serde(rename = "Mode")]
    mode: ServiceListSpecEndpointSpecMode,
    #[serde(rename = "Ports")]
    ports: Vec<EndpointPortConfig>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct EngineDescription {
    #[serde(rename = "EngineVersion")]
    engine_version: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Plugins")]
    plugins: Vec<NodeListDescriptionEnginePlugins>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ErrorDetail {
    #[serde(rename = "code")]
    code: i64,
    #[serde(rename = "message")]
    message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ErrorResponse {
    #[serde(rename = "message")]
    message: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ExecInspect {
    #[serde(rename = "CanRemove")]
    can_remove: bool,
    #[serde(rename = "DetachKeys")]
    detach_keys: String,
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Running")]
    running: bool,
    #[serde(rename = "ExitCode")]
    exit_code: i64,
    #[serde(rename = "ProcessConfig")]
    process_config: ProcessConfig,
    #[serde(rename = "OpenStdin")]
    open_stdin: bool,
    #[serde(rename = "OpenStderr")]
    open_stderr: bool,
    #[serde(rename = "OpenStdout")]
    open_stdout: bool,
    #[serde(rename = "ContainerID")]
    container_id: String,
    #[serde(rename = "Pid")]
    pid: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ExecStart {
    #[serde(rename = "Detach")]
    detach: bool,
    #[serde(rename = "Tty")]
    tty: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct GetPluginPrivileges {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Value")]
    value: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct GraphDriverData {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Data")]
    data: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct HealthConfig {
    #[serde(rename = "Test")]
    test: Vec<String>,
    #[serde(rename = "Interval")]
    interval: i64,
    #[serde(rename = "Timeout")]
    timeout: i64,
    #[serde(rename = "Retries")]
    retries: i64,
    #[serde(rename = "StartPeriod")]
    start_period: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct HostConfig {
    #[serde(rename = "CpuShares")]
    cpu_shares: i64,
    #[serde(rename = "Memory")]
    memory: i64,
    #[serde(rename = "CgroupParent")]
    cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    cpuset_mems: String,
    #[serde(rename = "Devices")]
    devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    oom_kill_disable: bool,
    #[serde(rename = "Init")]
    init: bool,
    #[serde(rename = "PidsLimit")]
    pids_limit: i64,
    #[serde(rename = "Ulimits")]
    ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    io_maximum_bandwidth: i64,
    #[serde(rename = "Binds")]
    binds: Vec<String>,
    #[serde(rename = "ContainerIDFile")]
    container_id_file: String,
    #[serde(rename = "LogConfig")]
    log_config: ContainerCreateHostConfigLogConfig,
    #[serde(rename = "NetworkMode")]
    network_mode: String,
    #[serde(rename = "PortBindings")]
    port_bindings: ::serde_json::Value,
    #[serde(rename = "RestartPolicy")]
    restart_policy: RestartPolicy,
    #[serde(rename = "AutoRemove")]
    auto_remove: bool,
    #[serde(rename = "VolumeDriver")]
    volume_driver: String,
    #[serde(rename = "VolumesFrom")]
    volumes_from: Vec<String>,
    #[serde(rename = "Mounts")]
    mounts: Vec<Mount>,
    #[serde(rename = "CapAdd")]
    cap_add: Vec<String>,
    #[serde(rename = "CapDrop")]
    cap_drop: Vec<String>,
    #[serde(rename = "Dns")]
    dns: Vec<String>,
    #[serde(rename = "DnsOptions")]
    dns_options: Vec<String>,
    #[serde(rename = "DnsSearch")]
    dns_search: Vec<String>,
    #[serde(rename = "ExtraHosts")]
    extra_hosts: Vec<String>,
    #[serde(rename = "GroupAdd")]
    group_add: Vec<String>,
    #[serde(rename = "IpcMode")]
    ipc_mode: String,
    #[serde(rename = "Cgroup")]
    cgroup: String,
    #[serde(rename = "Links")]
    links: Vec<String>,
    #[serde(rename = "OomScoreAdj")]
    oom_score_adj: i64,
    #[serde(rename = "PidMode")]
    pid_mode: String,
    #[serde(rename = "Privileged")]
    privileged: bool,
    #[serde(rename = "PublishAllPorts")]
    publish_all_ports: bool,
    #[serde(rename = "ReadonlyRootfs")]
    readonly_rootfs: bool,
    #[serde(rename = "SecurityOpt")]
    security_opt: Vec<String>,
    #[serde(rename = "StorageOpt")]
    storage_opt: ::serde_json::Value,
    #[serde(rename = "Tmpfs")]
    tmpfs: ::serde_json::Value,
    #[serde(rename = "UTSMode")]
    uts_mode: String,
    #[serde(rename = "UsernsMode")]
    userns_mode: String,
    #[serde(rename = "ShmSize")]
    shm_size: u64,
    #[serde(rename = "Sysctls")]
    sysctls: ::serde_json::Value,
    #[serde(rename = "Runtime")]
    runtime: String,
    #[serde(rename = "ConsoleSize")]
    console_size: Vec<u64>,
    #[serde(rename = "Isolation")]
    isolation: ContainerCreateHostConfigIsolation,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct IPAM {
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "Config")]
    config: Vec<::serde_json::Value>,
    #[serde(rename = "Options")]
    options: Vec<::serde_json::Value>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct IdResponse {
    #[serde(rename = "Id")]
    id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Image {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "RepoTags")]
    repo_tags: Vec<String>,
    #[serde(rename = "RepoDigests")]
    repo_digests: Vec<String>,
    #[serde(rename = "Parent")]
    parent: String,
    #[serde(rename = "Comment")]
    comment: String,
    #[serde(rename = "Created")]
    created: String,
    #[serde(rename = "Container")]
    container: String,
    #[serde(rename = "ContainerConfig")]
    container_config: ContainerConfig,
    #[serde(rename = "DockerVersion")]
    docker_version: String,
    #[serde(rename = "Author")]
    author: String,
    #[serde(rename = "Config")]
    config: ContainerConfig,
    #[serde(rename = "Architecture")]
    architecture: String,
    #[serde(rename = "Os")]
    os: String,
    #[serde(rename = "OsVersion")]
    os_version: String,
    #[serde(rename = "Size")]
    size: i64,
    #[serde(rename = "VirtualSize")]
    virtual_size: i64,
    #[serde(rename = "GraphDriver")]
    graph_driver: GraphDriverData,
    #[serde(rename = "RootFS")]
    root_fs: ImageInspectRootFS,
    #[serde(rename = "Metadata")]
    metadata: ImageInspectMetadata,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ImageBuild {
    #[serde(rename = "application/x-tar")]
    Applicationxtar,
}

impl Default for ImageBuild {
    fn default() -> Self {
        ImageBuild::Applicationxtar
    }
}

impl ToString for ImageBuild {
    fn to_string(&self) -> String {
        match self {
            ImageBuild::Applicationxtar => "application/x-tar",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageDeleteResponseItem {
    #[serde(rename = "Untagged")]
    untagged: String,
    #[serde(rename = "Deleted")]
    deleted: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageHistory {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Created")]
    created: i64,
    #[serde(rename = "CreatedBy")]
    created_by: String,
    #[serde(rename = "Tags")]
    tags: Vec<String>,
    #[serde(rename = "Size")]
    size: i64,
    #[serde(rename = "Comment")]
    comment: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageID {
    #[serde(rename = "ID")]
    id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageInspectMetadata {
    #[serde(rename = "LastTagTime")]
    last_tag_time: ::chrono::DateTime<::chrono::Utc>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageInspectRootFS {
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Layers")]
    layers: Vec<String>,
    #[serde(rename = "BaseLayer")]
    base_layer: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImagePrune {
    #[serde(rename = "ImagesDeleted")]
    images_deleted: Vec<ImageDeleteResponseItem>,
    #[serde(rename = "SpaceReclaimed")]
    space_reclaimed: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageSearch {
    #[serde(rename = "description")]
    description: String,
    #[serde(rename = "is_official")]
    is_official: bool,
    #[serde(rename = "is_automated")]
    is_automated: bool,
    #[serde(rename = "name")]
    name: String,
    #[serde(rename = "star_count")]
    star_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ImageSummary {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "ParentId")]
    parent_id: String,
    #[serde(rename = "RepoTags")]
    repo_tags: Vec<String>,
    #[serde(rename = "RepoDigests")]
    repo_digests: Vec<String>,
    #[serde(rename = "Created")]
    created: i64,
    #[serde(rename = "Size")]
    size: i64,
    #[serde(rename = "SharedSize")]
    shared_size: i64,
    #[serde(rename = "VirtualSize")]
    virtual_size: i64,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Containers")]
    containers: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct IndexInfo {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Mirrors")]
    mirrors: Vec<String>,
    #[serde(rename = "Secure")]
    secure: bool,
    #[serde(rename = "Official")]
    official: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct JoinTokens {
    #[serde(rename = "Worker")]
    worker: String,
    #[serde(rename = "Manager")]
    manager: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum LocalNodeState {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "inactive")]
    Inactive,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "locked")]
    Locked,
}

impl Default for LocalNodeState {
    fn default() -> Self {
        LocalNodeState::Empty
    }
}

impl ToString for LocalNodeState {
    fn to_string(&self) -> String {
        match self {
            LocalNodeState::Empty => "",
            LocalNodeState::Inactive => "inactive",
            LocalNodeState::Pending => "pending",
            LocalNodeState::Active => "active",
            LocalNodeState::Error => "error",
            LocalNodeState::Locked => "locked",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ManagerStatus {
    #[serde(rename = "Leader")]
    leader: bool,
    #[serde(rename = "Reachability")]
    reachability: Reachability,
    #[serde(rename = "Addr")]
    addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Mount {
    #[serde(rename = "Target")]
    target: String,
    #[serde(rename = "Source")]
    source: String,
    #[serde(rename = "Type")]
    type_: ContainerListMountsType,
    #[serde(rename = "ReadOnly")]
    read_only: bool,
    #[serde(rename = "Consistency")]
    consistency: String,
    #[serde(rename = "BindOptions")]
    bind_options: ContainerListMountsBindOptions,
    #[serde(rename = "VolumeOptions")]
    volume_options: ContainerListMountsVolumeOptions,
    #[serde(rename = "TmpfsOptions")]
    tmpfs_options: ContainerListMountsTmpfsOptions,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct MountPoint {
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Source")]
    source: String,
    #[serde(rename = "Destination")]
    destination: String,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "Mode")]
    mode: String,
    #[serde(rename = "RW")]
    rw: bool,
    #[serde(rename = "Propagation")]
    propagation: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Network {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Created")]
    created: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Scope")]
    scope: String,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "EnableIPv6")]
    enable_i_pv6: bool,
    #[serde(rename = "IPAM")]
    ipam: IPAM,
    #[serde(rename = "Internal")]
    internal: bool,
    #[serde(rename = "Attachable")]
    attachable: bool,
    #[serde(rename = "Ingress")]
    ingress: bool,
    #[serde(rename = "Containers")]
    containers: ::serde_json::Value,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkConnect {
    #[serde(rename = "Container")]
    container: String,
    #[serde(rename = "EndpointConfig")]
    endpoint_config: EndpointSettings,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkContainer {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "EndpointID")]
    endpoint_id: String,
    #[serde(rename = "MacAddress")]
    mac_address: String,
    #[serde(rename = "IPv4Address")]
    i_pv4_address: String,
    #[serde(rename = "IPv6Address")]
    i_pv6_address: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkCreateCreated {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Warning")]
    warning: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkCreateNetworkConfig {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "CheckDuplicate")]
    check_duplicate: bool,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "Internal")]
    internal: bool,
    #[serde(rename = "Attachable")]
    attachable: bool,
    #[serde(rename = "Ingress")]
    ingress: bool,
    #[serde(rename = "IPAM")]
    ipam: IPAM,
    #[serde(rename = "EnableIPv6")]
    enable_i_pv6: bool,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkDisconnect {
    #[serde(rename = "Container")]
    container: String,
    #[serde(rename = "Force")]
    force: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkPrune {
    #[serde(rename = "NetworksDeleted")]
    networks_deleted: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NetworkSettings {
    #[serde(rename = "Bridge")]
    bridge: String,
    #[serde(rename = "SandboxID")]
    sandbox_id: String,
    #[serde(rename = "HairpinMode")]
    hairpin_mode: bool,
    #[serde(rename = "LinkLocalIPv6Address")]
    link_local_i_pv6_address: String,
    #[serde(rename = "LinkLocalIPv6PrefixLen")]
    link_local_i_pv6_prefix_len: i64,
    #[serde(rename = "Ports")]
    ports: ::serde_json::Value,
    #[serde(rename = "SandboxKey")]
    sandbox_key: String,
    #[serde(rename = "SecondaryIPAddresses")]
    secondary_ip_addresses: Vec<Address>,
    #[serde(rename = "SecondaryIPv6Addresses")]
    secondary_i_pv6_addresses: Vec<Address>,
    #[serde(rename = "EndpointID")]
    endpoint_id: String,
    #[serde(rename = "Gateway")]
    gateway: String,
    #[serde(rename = "GlobalIPv6Address")]
    global_i_pv6_address: String,
    #[serde(rename = "GlobalIPv6PrefixLen")]
    global_i_pv6_prefix_len: i64,
    #[serde(rename = "IPAddress")]
    ip_address: String,
    #[serde(rename = "IPPrefixLen")]
    ip_prefix_len: i64,
    #[serde(rename = "IPv6Gateway")]
    i_pv6_gateway: String,
    #[serde(rename = "MacAddress")]
    mac_address: String,
    #[serde(rename = "Networks")]
    networks: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Node {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: NodeSpec,
    #[serde(rename = "Description")]
    description: NodeDescription,
    #[serde(rename = "Status")]
    status: NodeStatus,
    #[serde(rename = "ManagerStatus")]
    manager_status: ManagerStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NodeDescription {
    #[serde(rename = "Hostname")]
    hostname: String,
    #[serde(rename = "Platform")]
    platform: Platform,
    #[serde(rename = "Resources")]
    resources: ResourceObject,
    #[serde(rename = "Engine")]
    engine: EngineDescription,
    #[serde(rename = "TLSInfo")]
    tls_info: TLSInfo,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NodeListDescriptionEnginePlugins {
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Name")]
    name: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum NodeListSpecAvailability {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "pause")]
    Pause,
    #[serde(rename = "drain")]
    Drain,
}

impl ToString for NodeListSpecAvailability {
    fn to_string(&self) -> String {
        match self {
            NodeListSpecAvailability::Active => "active",
            NodeListSpecAvailability::Pause => "pause",
            NodeListSpecAvailability::Drain => "drain",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum NodeListSpecRole {
    #[serde(rename = "worker")]
    Worker,
    #[serde(rename = "manager")]
    Manager,
}

impl ToString for NodeListSpecRole {
    fn to_string(&self) -> String {
        match self {
            NodeListSpecRole::Worker => "worker",
            NodeListSpecRole::Manager => "manager",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NodeSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Role")]
    role: NodeListSpecRole,
    #[serde(rename = "Availability")]
    availability: NodeListSpecAvailability,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum NodeState {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "down")]
    Down,
    #[serde(rename = "ready")]
    Ready,
    #[serde(rename = "disconnected")]
    Disconnected,
}

impl ToString for NodeState {
    fn to_string(&self) -> String {
        match self {
            NodeState::Unknown => "unknown",
            NodeState::Down => "down",
            NodeState::Ready => "ready",
            NodeState::Disconnected => "disconnected",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct NodeStatus {
    #[serde(rename = "State")]
    state: NodeState,
    #[serde(rename = "Message")]
    message: String,
    #[serde(rename = "Addr")]
    addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ObjectVersion {
    #[serde(rename = "Inde")]
    inde: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PeerNode {
    #[serde(rename = "NodeID")]
    node_id: String,
    #[serde(rename = "Addr")]
    addr: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Platform {
    #[serde(rename = "Architecture")]
    architecture: String,
    #[serde(rename = "OS")]
    os: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Plugin {
    #[serde(rename = "Id")]
    id: String,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Enabled")]
    enabled: bool,
    #[serde(rename = "Settings")]
    settings: PluginListSettings,
    #[serde(rename = "PluginReference")]
    plugin_reference: String,
    #[serde(rename = "Config")]
    config: PluginListConfig,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginDevice {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Settable")]
    settable: Vec<String>,
    #[serde(rename = "Path")]
    path: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginEnv {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Settable")]
    settable: Vec<String>,
    #[serde(rename = "Value")]
    value: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginInterfaceType {
    #[serde(rename = "Prefix")]
    prefix: String,
    #[serde(rename = "Capability")]
    capability: String,
    #[serde(rename = "Version")]
    version: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfig {
    #[serde(rename = "DockerVersion")]
    docker_version: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Documentation")]
    documentation: String,
    #[serde(rename = "Interface")]
    interface: PluginListConfigInterface,
    #[serde(rename = "Entrypoint")]
    entrypoint: Vec<String>,
    #[serde(rename = "WorkDir")]
    work_dir: String,
    #[serde(rename = "User")]
    user: PluginListConfigUser,
    #[serde(rename = "Network")]
    network: PluginListConfigNetwork,
    #[serde(rename = "Linux")]
    linux: PluginListConfigLinux,
    #[serde(rename = "PropagatedMount")]
    propagated_mount: String,
    #[serde(rename = "IpcHost")]
    ipc_host: bool,
    #[serde(rename = "PidHost")]
    pid_host: bool,
    #[serde(rename = "Mounts")]
    mounts: Vec<PluginMount>,
    #[serde(rename = "Env")]
    env: Vec<PluginEnv>,
    #[serde(rename = "Args")]
    args: PluginListConfigArgs,
    #[serde(rename = "rootfs")]
    rootfs: PluginListConfigrootfs,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigArgs {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Settable")]
    settable: Vec<String>,
    #[serde(rename = "Value")]
    value: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigInterface {
    #[serde(rename = "Types")]
    types: Vec<PluginInterfaceType>,
    #[serde(rename = "Socket")]
    socket: String,
    #[serde(rename = "ProtocolScheme")]
    protocol_scheme: PluginListConfigInterfaceProtocolScheme,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum PluginListConfigInterfaceProtocolScheme {
    #[serde(rename = "")]
    Empty,
    #[serde(rename = "moby.plugins.http/v1")]
    Mobypluginshttpv1,
}

impl ToString for PluginListConfigInterfaceProtocolScheme {
    fn to_string(&self) -> String {
        match self {
            PluginListConfigInterfaceProtocolScheme::Empty => "",
            PluginListConfigInterfaceProtocolScheme::Mobypluginshttpv1 => "moby.plugins.http/v1",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigLinux {
    #[serde(rename = "Capabilities")]
    capabilities: Vec<String>,
    #[serde(rename = "AllowAllDevices")]
    allow_all_devices: bool,
    #[serde(rename = "Devices")]
    devices: Vec<PluginDevice>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigNetwork {
    #[serde(rename = "Type")]
    type_: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigUser {
    #[serde(rename = "UID")]
    uid: u32,
    #[serde(rename = "GID")]
    gid: u32,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListConfigrootfs {
    #[serde(rename = "type")]
    type_: String,
    #[serde(rename = "diff_ids")]
    diff_ids: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginListSettings {
    #[serde(rename = "Mounts")]
    mounts: Vec<PluginMount>,
    #[serde(rename = "Env")]
    env: Vec<String>,
    #[serde(rename = "Args")]
    args: Vec<String>,
    #[serde(rename = "Devices")]
    devices: Vec<PluginDevice>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginMount {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Description")]
    description: String,
    #[serde(rename = "Settable")]
    settable: Vec<String>,
    #[serde(rename = "Source")]
    source: String,
    #[serde(rename = "Destination")]
    destination: String,
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Options")]
    options: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PluginsInfo {
    #[serde(rename = "Volume")]
    volume: Vec<String>,
    #[serde(rename = "Network")]
    network: Vec<String>,
    #[serde(rename = "Authorization")]
    authorization: Vec<String>,
    #[serde(rename = "Log")]
    log: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Port {
    #[serde(rename = "IP")]
    ip: ::std::net::IpAddr,
    #[serde(rename = "PrivatePort")]
    private_port: u16,
    #[serde(rename = "PublicPort")]
    public_port: u16,
    #[serde(rename = "Type")]
    type_: ContainerListPortsType,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PortBinding {
    #[serde(rename = "HostIp")]
    host_ip: String,
    #[serde(rename = "HostPort")]
    host_port: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ProcessConfig {
    #[serde(rename = "privileged")]
    privileged: bool,
    #[serde(rename = "user")]
    user: String,
    #[serde(rename = "tty")]
    tty: bool,
    #[serde(rename = "entrypoint")]
    entrypoint: String,
    #[serde(rename = "arguments")]
    arguments: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ProgressDetail {
    #[serde(rename = "current")]
    current: i64,
    #[serde(rename = "total")]
    total: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct PushImageInfo {
    #[serde(rename = "error")]
    error: String,
    #[serde(rename = "status")]
    status: String,
    #[serde(rename = "progress")]
    progress: String,
    #[serde(rename = "progressDetail")]
    progress_detail: ProgressDetail,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum Reachability {
    #[serde(rename = "unknown")]
    Unknown,
    #[serde(rename = "unreachable")]
    Unreachable,
    #[serde(rename = "reachable")]
    Reachable,
}

impl ToString for Reachability {
    fn to_string(&self) -> String {
        match self {
            Reachability::Unknown => "unknown",
            Reachability::Unreachable => "unreachable",
            Reachability::Reachable => "reachable",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct RegistryServiceConfig {
    #[serde(rename = "AllowNondistributableArtifactsCIDRs")]
    allow_nondistributable_artifacts_cid_rs: Vec<String>,
    #[serde(rename = "AllowNondistributableArtifactsHostnames")]
    allow_nondistributable_artifacts_hostnames: Vec<String>,
    #[serde(rename = "InsecureRegistryCIDRs")]
    insecure_registry_cid_rs: Vec<String>,
    #[serde(rename = "IndexConfigs")]
    index_configs: ::serde_json::Value,
    #[serde(rename = "Mirrors")]
    mirrors: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ResourceObject {
    #[serde(rename = "NanoCPUs")]
    nano_cp_us: i64,
    #[serde(rename = "MemoryBytes")]
    memory_bytes: i64,
    #[serde(rename = "GenericResources")]
    generic_resources: Vec<SystemInfoGenericResources>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Resources {
    #[serde(rename = "CpuShares")]
    cpu_shares: i64,
    #[serde(rename = "Memory")]
    memory: i64,
    #[serde(rename = "CgroupParent")]
    cgroup_parent: String,
    #[serde(rename = "BlkioWeight")]
    blkio_weight: u64,
    #[serde(rename = "BlkioWeightDevice")]
    blkio_weight_device: Vec<ContainerCreateHostConfigBlkioWeightDevice>,
    #[serde(rename = "BlkioDeviceReadBps")]
    blkio_device_read_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteBps")]
    blkio_device_write_bps: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceReadIOps")]
    blkio_device_read_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "BlkioDeviceWriteIOps")]
    blkio_device_write_i_ops: Vec<ThrottleDevice>,
    #[serde(rename = "CpuPeriod")]
    cpu_period: i64,
    #[serde(rename = "CpuQuota")]
    cpu_quota: i64,
    #[serde(rename = "CpuRealtimePeriod")]
    cpu_realtime_period: i64,
    #[serde(rename = "CpuRealtimeRuntime")]
    cpu_realtime_runtime: i64,
    #[serde(rename = "CpusetCpus")]
    cpuset_cpus: String,
    #[serde(rename = "CpusetMems")]
    cpuset_mems: String,
    #[serde(rename = "Devices")]
    devices: Vec<DeviceMapping>,
    #[serde(rename = "DeviceCgroupRules")]
    device_cgroup_rules: Vec<String>,
    #[serde(rename = "DiskQuota")]
    disk_quota: i64,
    #[serde(rename = "KernelMemory")]
    kernel_memory: i64,
    #[serde(rename = "MemoryReservation")]
    memory_reservation: i64,
    #[serde(rename = "MemorySwap")]
    memory_swap: i64,
    #[serde(rename = "MemorySwappiness")]
    memory_swappiness: u64,
    #[serde(rename = "NanoCPUs")]
    nano_cp_us: i64,
    #[serde(rename = "OomKillDisable")]
    oom_kill_disable: bool,
    #[serde(rename = "Init")]
    init: bool,
    #[serde(rename = "PidsLimit")]
    pids_limit: i64,
    #[serde(rename = "Ulimits")]
    ulimits: Vec<ContainerCreateHostConfigUlimits>,
    #[serde(rename = "CpuCount")]
    cpu_count: i64,
    #[serde(rename = "CpuPercent")]
    cpu_percent: i64,
    #[serde(rename = "IOMaximumIOps")]
    io_maximum_i_ops: i64,
    #[serde(rename = "IOMaximumBandwidth")]
    io_maximum_bandwidth: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct RestartPolicy {
    #[serde(rename = "Name")]
    name: ContainerCreateHostConfigRestartPolicyName,
    #[serde(rename = "MaximumRetryCount")]
    maximum_retry_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Runtime {
    #[serde(rename = "path")]
    path: String,
    #[serde(rename = "runtimeArgs")]
    runtime_args: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Secret {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: SecretSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SecretSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Data")]
    data: String,
    #[serde(rename = "Driver")]
    driver: Driver,
    #[serde(rename = "Templating")]
    templating: Driver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Service {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: ServiceSpec,
    #[serde(rename = "Endpoint")]
    endpoint: ServiceListEndpoint,
    #[serde(rename = "UpdateStatus")]
    update_status: ServiceListUpdateStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceCreate {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Warning")]
    warning: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListEndpoint {
    #[serde(rename = "Spec")]
    spec: EndpointSpec,
    #[serde(rename = "Ports")]
    ports: Vec<EndpointPortConfig>,
    #[serde(rename = "VirtualIPs")]
    virtual_i_ps: Vec<ServiceListEndpointVirtualIPs>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListEndpointVirtualIPs {
    #[serde(rename = "NetworkID")]
    network_id: String,
    #[serde(rename = "Addr")]
    addr: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecEndpointSpecMode {
    #[serde(rename = "vip")]
    Vip,
    #[serde(rename = "dnsrr")]
    Dnsrr,
}

impl Default for ServiceListSpecEndpointSpecMode {
    fn default() -> Self {
        ServiceListSpecEndpointSpecMode::Vip
    }
}

impl ToString for ServiceListSpecEndpointSpecMode {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecEndpointSpecMode::Vip => "vip",
            ServiceListSpecEndpointSpecMode::Dnsrr => "dnsrr",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecEndpointSpecPortsPublishMode {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "host")]
    Host,
}

impl Default for ServiceListSpecEndpointSpecPortsPublishMode {
    fn default() -> Self {
        ServiceListSpecEndpointSpecPortsPublishMode::Ingress
    }
}

impl ToString for ServiceListSpecEndpointSpecPortsPublishMode {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecEndpointSpecPortsPublishMode::Ingress => "ingress",
            ServiceListSpecEndpointSpecPortsPublishMode::Host => "host",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecMode {
    #[serde(rename = "Replicated")]
    replicated: ServiceListSpecModeReplicated,
    #[serde(rename = "Global")]
    global: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecModeReplicated {
    #[serde(rename = "Replicas")]
    replicas: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecRollbackConfig {
    #[serde(rename = "Parallelism")]
    parallelism: i64,
    #[serde(rename = "Delay")]
    delay: i64,
    #[serde(rename = "FailureAction")]
    failure_action: ServiceListSpecRollbackConfigFailureAction,
    #[serde(rename = "Monitor")]
    monitor: i64,
    #[serde(rename = "MaxFailureRatio")]
    max_failure_ratio: f64,
    #[serde(rename = "Order")]
    order: ServiceListSpecUpdateConfigOrder,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecRollbackConfigFailureAction {
    #[serde(rename = "continue")]
    Continue,
    #[serde(rename = "pause")]
    Pause,
}

impl ToString for ServiceListSpecRollbackConfigFailureAction {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecRollbackConfigFailureAction::Continue => "continue",
            ServiceListSpecRollbackConfigFailureAction::Pause => "pause",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpec {
    #[serde(rename = "Image")]
    image: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Command")]
    command: Vec<String>,
    #[serde(rename = "Args")]
    args: Vec<String>,
    #[serde(rename = "Hostname")]
    hostname: String,
    #[serde(rename = "Env")]
    env: Vec<String>,
    #[serde(rename = "Dir")]
    dir: String,
    #[serde(rename = "User")]
    user: String,
    #[serde(rename = "Groups")]
    groups: Vec<String>,
    #[serde(rename = "Privileges")]
    privileges: ServiceListSpecTaskTemplateContainerSpecPrivileges,
    #[serde(rename = "TTY")]
    tty: bool,
    #[serde(rename = "OpenStdin")]
    open_stdin: bool,
    #[serde(rename = "ReadOnly")]
    read_only: bool,
    #[serde(rename = "Mounts")]
    mounts: Vec<Mount>,
    #[serde(rename = "StopSignal")]
    stop_signal: String,
    #[serde(rename = "StopGracePeriod")]
    stop_grace_period: i64,
    #[serde(rename = "HealthCheck")]
    health_check: HealthConfig,
    #[serde(rename = "Hosts")]
    hosts: Vec<String>,
    #[serde(rename = "DNSConfig")]
    dns_config: ServiceListSpecTaskTemplateContainerSpecDNSConfig,
    #[serde(rename = "Secrets")]
    secrets: Vec<ServiceListSpecTaskTemplateContainerSpecSecrets>,
    #[serde(rename = "Configs")]
    configs: Vec<ServiceListSpecTaskTemplateContainerSpecConfigs>,
    #[serde(rename = "Isolation")]
    isolation: ContainerCreateHostConfigIsolation,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecConfigs {
    #[serde(rename = "File")]
    file: ServiceListSpecTaskTemplateContainerSpecSecretsFile,
    #[serde(rename = "ConfigID")]
    config_id: String,
    #[serde(rename = "ConfigName")]
    config_name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecDNSConfig {
    #[serde(rename = "Nameservers")]
    nameservers: Vec<String>,
    #[serde(rename = "Search")]
    search: Vec<String>,
    #[serde(rename = "Options")]
    options: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecPrivileges {
    #[serde(rename = "CredentialSpec")]
    credential_spec: ServiceListSpecTaskTemplateContainerSpecPrivilegesCredentialSpec,
    #[serde(rename = "SELinuxContext")]
    se_linux_context: ServiceListSpecTaskTemplateContainerSpecPrivilegesSELinuxContext,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecPrivilegesCredentialSpec {
    #[serde(rename = "File")]
    file: String,
    #[serde(rename = "Registry")]
    registry: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecPrivilegesSELinuxContext {
    #[serde(rename = "Disable")]
    disable: bool,
    #[serde(rename = "User")]
    user: String,
    #[serde(rename = "Role")]
    role: String,
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Level")]
    level: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecSecrets {
    #[serde(rename = "File")]
    file: ServiceListSpecTaskTemplateContainerSpecSecretsFile,
    #[serde(rename = "SecretID")]
    secret_id: String,
    #[serde(rename = "SecretName")]
    secret_name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateContainerSpecSecretsFile {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "UID")]
    uid: String,
    #[serde(rename = "GID")]
    gid: String,
    #[serde(rename = "Mode")]
    mode: u32,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateLogDriver {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateNetworkAttachmentSpec {
    #[serde(rename = "ContainerID")]
    container_id: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateNetworks {
    #[serde(rename = "Target")]
    target: String,
    #[serde(rename = "Aliases")]
    aliases: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplatePlacement {
    #[serde(rename = "Constraints")]
    constraints: Vec<String>,
    #[serde(rename = "Preferences")]
    preferences: Vec<ServiceListSpecTaskTemplatePlacementPreferences>,
    #[serde(rename = "Platforms")]
    platforms: Vec<Platform>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplatePlacementPreferences {
    #[serde(rename = "Spread")]
    spread: ServiceListSpecTaskTemplatePlacementPreferencesSpread,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplatePlacementPreferencesSpread {
    #[serde(rename = "SpreadDescriptor")]
    spread_descriptor: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplatePluginSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Remote")]
    remote: String,
    #[serde(rename = "Disabled")]
    disabled: bool,
    #[serde(rename = "PluginPrivilege")]
    plugin_privilege: Vec<GetPluginPrivileges>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateResources {
    #[serde(rename = "Limits")]
    limits: ResourceObject,
    #[serde(rename = "Reservation")]
    reservation: ResourceObject,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecTaskTemplateRestartPolicy {
    #[serde(rename = "Condition")]
    condition: ServiceListSpecTaskTemplateRestartPolicyCondition,
    #[serde(rename = "Delay")]
    delay: i64,
    #[serde(rename = "MaxAttempts")]
    max_attempts: i64,
    #[serde(rename = "Window")]
    window: i64,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecTaskTemplateRestartPolicyCondition {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "on-failure")]
    Onfailure,
    #[serde(rename = "any")]
    Any,
}

impl ToString for ServiceListSpecTaskTemplateRestartPolicyCondition {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecTaskTemplateRestartPolicyCondition::None => "none",
            ServiceListSpecTaskTemplateRestartPolicyCondition::Onfailure => "on-failure",
            ServiceListSpecTaskTemplateRestartPolicyCondition::Any => "any",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListSpecUpdateConfig {
    #[serde(rename = "Parallelism")]
    parallelism: i64,
    #[serde(rename = "Delay")]
    delay: i64,
    #[serde(rename = "FailureAction")]
    failure_action: ServiceListSpecUpdateConfigFailureAction,
    #[serde(rename = "Monitor")]
    monitor: i64,
    #[serde(rename = "MaxFailureRatio")]
    max_failure_ratio: f64,
    #[serde(rename = "Order")]
    order: ServiceListSpecUpdateConfigOrder,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecUpdateConfigFailureAction {
    #[serde(rename = "continue")]
    Continue,
    #[serde(rename = "pause")]
    Pause,
    #[serde(rename = "rollback")]
    Rollback,
}

impl ToString for ServiceListSpecUpdateConfigFailureAction {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecUpdateConfigFailureAction::Continue => "continue",
            ServiceListSpecUpdateConfigFailureAction::Pause => "pause",
            ServiceListSpecUpdateConfigFailureAction::Rollback => "rollback",
        }.to_string()
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListSpecUpdateConfigOrder {
    #[serde(rename = "stop-first")]
    Stopfirst,
    #[serde(rename = "start-first")]
    Startfirst,
}

impl ToString for ServiceListSpecUpdateConfigOrder {
    fn to_string(&self) -> String {
        match self {
            ServiceListSpecUpdateConfigOrder::Stopfirst => "stop-first",
            ServiceListSpecUpdateConfigOrder::Startfirst => "start-first",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceListUpdateStatus {
    #[serde(rename = "State")]
    state: ServiceListUpdateStatusState,
    #[serde(rename = "StartedAt")]
    started_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "CompletedAt")]
    completed_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Message")]
    message: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum ServiceListUpdateStatusState {
    #[serde(rename = "updating")]
    Updating,
    #[serde(rename = "paused")]
    Paused,
    #[serde(rename = "completed")]
    Completed,
}

impl ToString for ServiceListUpdateStatusState {
    fn to_string(&self) -> String {
        match self {
            ServiceListUpdateStatusState::Updating => "updating",
            ServiceListUpdateStatusState::Paused => "paused",
            ServiceListUpdateStatusState::Completed => "completed",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "TaskTemplate")]
    task_template: TaskSpec,
    #[serde(rename = "Mode")]
    mode: ServiceListSpecMode,
    #[serde(rename = "UpdateConfig")]
    update_config: ServiceListSpecUpdateConfig,
    #[serde(rename = "RollbackConfig")]
    rollback_config: ServiceListSpecRollbackConfig,
    #[serde(rename = "Networks")]
    networks: Vec<ServiceListSpecTaskTemplateNetworks>,
    #[serde(rename = "EndpointSpec")]
    endpoint_spec: EndpointSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ServiceUpdateResponse {
    #[serde(rename = "Warnings")]
    warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Swarm {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Spec")]
    spec: SwarmSpec,
    #[serde(rename = "TLSInfo")]
    tls_info: TLSInfo,
    #[serde(rename = "RootRotationInProgress")]
    root_rotation_in_progress: bool,
    #[serde(rename = "JoinTokens")]
    join_tokens: JoinTokens,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SwarmInfo {
    #[serde(rename = "NodeID")]
    node_id: String,
    #[serde(rename = "NodeAddr")]
    node_addr: String,
    #[serde(rename = "LocalNodeState")]
    local_node_state: LocalNodeState,
    #[serde(rename = "ControlAvailable")]
    control_available: bool,
    #[serde(rename = "Error")]
    error: String,
    #[serde(rename = "RemoteManagers")]
    remote_managers: Vec<PeerNode>,
    #[serde(rename = "Nodes")]
    nodes: i64,
    #[serde(rename = "Managers")]
    managers: i64,
    #[serde(rename = "Cluster")]
    cluster: ClusterInfo,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SwarmInit {
    #[serde(rename = "ListenAddr")]
    listen_addr: String,
    #[serde(rename = "AdvertiseAddr")]
    advertise_addr: String,
    #[serde(rename = "DataPathAddr")]
    data_path_addr: String,
    #[serde(rename = "ForceNewCluster")]
    force_new_cluster: bool,
    #[serde(rename = "Spec")]
    spec: SwarmSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SwarmJoin {
    #[serde(rename = "ListenAddr")]
    listen_addr: String,
    #[serde(rename = "AdvertiseAddr")]
    advertise_addr: String,
    #[serde(rename = "DataPathAddr")]
    data_path_addr: String,
    #[serde(rename = "RemoteAddrs")]
    remote_addrs: String,
    #[serde(rename = "JoinToken")]
    join_token: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SwarmSpec {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Orchestration")]
    orchestration: SystemInfoSwarmClusterSpecOrchestration,
    #[serde(rename = "Raft")]
    raft: SystemInfoSwarmClusterSpecRaft,
    #[serde(rename = "Dispatcher")]
    dispatcher: SystemInfoSwarmClusterSpecDispatcher,
    #[serde(rename = "CAConfig")]
    ca_config: SystemInfoSwarmClusterSpecCAConfig,
    #[serde(rename = "EncryptionConfig")]
    encryption_config: SystemInfoSwarmClusterSpecEncryptionConfig,
    #[serde(rename = "TaskDefaults")]
    task_defaults: SystemInfoSwarmClusterSpecTaskDefaults,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SwarmUnlockkey {
    #[serde(rename = "UnlockKey")]
    unlock_key: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemAuth {
    #[serde(rename = "Status")]
    status: String,
    #[serde(rename = "IdentityToken")]
    identity_token: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemDataUsage {
    #[serde(rename = "LayersSize")]
    layers_size: i64,
    #[serde(rename = "Images")]
    images: Vec<ImageSummary>,
    #[serde(rename = "Containers")]
    containers: Vec<Vec<ContainerList>>,
    #[serde(rename = "Volumes")]
    volumes: Vec<Volume>,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum SystemDataUsageVolumesScope {
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "global")]
    Global,
}

impl Default for SystemDataUsageVolumesScope {
    fn default() -> Self {
        SystemDataUsageVolumesScope::Local
    }
}

impl ToString for SystemDataUsageVolumesScope {
    fn to_string(&self) -> String {
        match self {
            SystemDataUsageVolumesScope::Local => "local",
            SystemDataUsageVolumesScope::Global => "global",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemDataUsageVolumesUsageData {
    #[serde(rename = "Size")]
    size: i64,
    #[serde(rename = "RefCount")]
    ref_count: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemEvents {
    #[serde(rename = "Type")]
    type_: String,
    #[serde(rename = "Action")]
    action: String,
    #[serde(rename = "Actor")]
    actor: SystemEventsActor,
    #[serde(rename = "time")]
    time: i64,
    #[serde(rename = "timeNano")]
    time_nano: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemEventsActor {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Attributes")]
    attributes: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfo {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Containers")]
    containers: i64,
    #[serde(rename = "ContainersRunning")]
    containers_running: i64,
    #[serde(rename = "ContainersPaused")]
    containers_paused: i64,
    #[serde(rename = "ContainersStopped")]
    containers_stopped: i64,
    #[serde(rename = "Images")]
    images: i64,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "DriverStatus")]
    driver_status: Vec<Vec<String>>,
    #[serde(rename = "DockerRootDir")]
    docker_root_dir: String,
    #[serde(rename = "SystemStatus")]
    system_status: Vec<Vec<String>>,
    #[serde(rename = "Plugins")]
    plugins: PluginsInfo,
    #[serde(rename = "MemoryLimit")]
    memory_limit: bool,
    #[serde(rename = "SwapLimit")]
    swap_limit: bool,
    #[serde(rename = "KernelMemory")]
    kernel_memory: bool,
    #[serde(rename = "CpuCfsPeriod")]
    cpu_cfs_period: bool,
    #[serde(rename = "CpuCfsQuota")]
    cpu_cfs_quota: bool,
    #[serde(rename = "CPUShares")]
    cpu_shares: bool,
    #[serde(rename = "CPUSet")]
    cpu_set: bool,
    #[serde(rename = "OomKillDisable")]
    oom_kill_disable: bool,
    #[serde(rename = "IPv4Forwarding")]
    i_pv4_forwarding: bool,
    #[serde(rename = "BridgeNfIptables")]
    bridge_nf_iptables: bool,
    #[serde(rename = "BridgeNfIp6tables")]
    bridge_nf_ip6tables: bool,
    #[serde(rename = "Debug")]
    debug: bool,
    #[serde(rename = "NFd")]
    n_fd: i64,
    #[serde(rename = "NGoroutines")]
    n_goroutines: i64,
    #[serde(rename = "SystemTime")]
    system_time: String,
    #[serde(rename = "LoggingDriver")]
    logging_driver: String,
    #[serde(rename = "CgroupDriver")]
    cgroup_driver: SystemInfoCgroupDriver,
    #[serde(rename = "NEventsListener")]
    n_events_listener: i64,
    #[serde(rename = "KernelVersion")]
    kernel_version: String,
    #[serde(rename = "OperatingSystem")]
    operating_system: String,
    #[serde(rename = "OSType")]
    os_type: String,
    #[serde(rename = "Architecture")]
    architecture: String,
    #[serde(rename = "NCPU")]
    ncpu: i64,
    #[serde(rename = "MemTotal")]
    mem_total: i64,
    #[serde(rename = "IndexServerAddress")]
    index_server_address: String,
    #[serde(rename = "RegistryConfig")]
    registry_config: RegistryServiceConfig,
    #[serde(rename = "GenericResources")]
    generic_resources: Vec<SystemInfoGenericResources>,
    #[serde(rename = "HttpProxy")]
    http_proxy: String,
    #[serde(rename = "HttpsProxy")]
    https_proxy: String,
    #[serde(rename = "NoProxy")]
    no_proxy: String,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: Vec<String>,
    #[serde(rename = "ExperimentalBuild")]
    experimental_build: bool,
    #[serde(rename = "ServerVersion")]
    server_version: String,
    #[serde(rename = "ClusterStore")]
    cluster_store: String,
    #[serde(rename = "ClusterAdvertise")]
    cluster_advertise: String,
    #[serde(rename = "Runtimes")]
    runtimes: ::serde_json::Value,
    #[serde(rename = "DefaultRuntime")]
    default_runtime: String,
    #[serde(rename = "Swarm")]
    swarm: SwarmInfo,
    #[serde(rename = "LiveRestoreEnabled")]
    live_restore_enabled: bool,
    #[serde(rename = "Isolation")]
    isolation: SystemInfoIsolation,
    #[serde(rename = "InitBinary")]
    init_binary: String,
    #[serde(rename = "ContainerdCommit")]
    containerd_commit: Commit,
    #[serde(rename = "RuncCommit")]
    runc_commit: Commit,
    #[serde(rename = "InitCommit")]
    init_commit: Commit,
    #[serde(rename = "SecurityOptions")]
    security_options: Vec<String>,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum SystemInfoCgroupDriver {
    #[serde(rename = "cgroupfs")]
    Cgroupfs,
    #[serde(rename = "systemd")]
    Systemd,
}

impl Default for SystemInfoCgroupDriver {
    fn default() -> Self {
        SystemInfoCgroupDriver::Cgroupfs
    }
}

impl ToString for SystemInfoCgroupDriver {
    fn to_string(&self) -> String {
        match self {
            SystemInfoCgroupDriver::Cgroupfs => "cgroupfs",
            SystemInfoCgroupDriver::Systemd => "systemd",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoGenericResources {
    #[serde(rename = "NamedResourceSpec")]
    named_resource_spec: SystemInfoGenericResourcesNamedResourceSpec,
    #[serde(rename = "DiscreteResourceSpec")]
    discrete_resource_spec: SystemInfoGenericResourcesDiscreteResourceSpec,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoGenericResourcesDiscreteResourceSpec {
    #[serde(rename = "Kind")]
    kind: String,
    #[serde(rename = "Value")]
    value: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoGenericResourcesNamedResourceSpec {
    #[serde(rename = "Kind")]
    kind: String,
    #[serde(rename = "Value")]
    value: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum SystemInfoIsolation {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "hyperv")]
    Hyperv,
    #[serde(rename = "process")]
    Process,
}

impl Default for SystemInfoIsolation {
    fn default() -> Self {
        SystemInfoIsolation::Default
    }
}

impl ToString for SystemInfoIsolation {
    fn to_string(&self) -> String {
        match self {
            SystemInfoIsolation::Default => "default",
            SystemInfoIsolation::Hyperv => "hyperv",
            SystemInfoIsolation::Process => "process",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecCAConfig {
    #[serde(rename = "NodeCertExpiry")]
    node_cert_expiry: i64,
    #[serde(rename = "ExternalCAs")]
    external_c_as: Vec<SystemInfoSwarmClusterSpecCAConfigExternalCAs>,
    #[serde(rename = "SigningCACert")]
    signing_ca_cert: String,
    #[serde(rename = "SigningCAKey")]
    signing_ca_key: String,
    #[serde(rename = "ForceRotate")]
    force_rotate: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecCAConfigExternalCAs {
    #[serde(rename = "Protocol")]
    protocol: SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol,
    #[serde(rename = "URL")]
    url: String,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
    #[serde(rename = "CACert")]
    ca_cert: String,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    #[serde(rename = "cfssl")]
    Cfssl,
}

impl Default for SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    fn default() -> Self {
        SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol::Cfssl
    }
}

impl ToString for SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol {
    fn to_string(&self) -> String {
        match self {
            SystemInfoSwarmClusterSpecCAConfigExternalCAsProtocol::Cfssl => "cfssl",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecDispatcher {
    #[serde(rename = "HeartbeatPeriod")]
    heartbeat_period: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecEncryptionConfig {
    #[serde(rename = "AutoLockManagers")]
    auto_lock_managers: bool,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecOrchestration {
    #[serde(rename = "TaskHistoryRetentionLimit")]
    task_history_retention_limit: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecRaft {
    #[serde(rename = "SnapshotInterval")]
    snapshot_interval: u64,
    #[serde(rename = "KeepOldSnapshots")]
    keep_old_snapshots: u64,
    #[serde(rename = "LogEntriesForSlowFollowers")]
    log_entries_for_slow_followers: u64,
    #[serde(rename = "ElectionTick")]
    election_tick: i64,
    #[serde(rename = "HeartbeatTick")]
    heartbeat_tick: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecTaskDefaults {
    #[serde(rename = "LogDriver")]
    log_driver: SystemInfoSwarmClusterSpecTaskDefaultsLogDriver,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemInfoSwarmClusterSpecTaskDefaultsLogDriver {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemVersion {
    #[serde(rename = "Platform")]
    platform: SystemVersionPlatform,
    #[serde(rename = "Components")]
    components: Vec<SystemVersionComponents>,
    #[serde(rename = "Version")]
    version: String,
    #[serde(rename = "ApiVersion")]
    api_version: String,
    #[serde(rename = "MinAPIVersion")]
    min_api_version: String,
    #[serde(rename = "GitCommit")]
    git_commit: String,
    #[serde(rename = "GoVersion")]
    go_version: String,
    #[serde(rename = "Os")]
    os: String,
    #[serde(rename = "Arch")]
    arch: String,
    #[serde(rename = "KernelVersion")]
    kernel_version: String,
    #[serde(rename = "Experimental")]
    experimental: bool,
    #[serde(rename = "BuildTime")]
    build_time: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemVersionComponents {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Version")]
    version: String,
    #[serde(rename = "Details")]
    details: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct SystemVersionPlatform {
    #[serde(rename = "Name")]
    name: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct TLSInfo {
    #[serde(rename = "TrustRoot")]
    trust_root: String,
    #[serde(rename = "CertIssuerSubject")]
    cert_issuer_subject: String,
    #[serde(rename = "CertIssuerPublicKey")]
    cert_issuer_public_key: String,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Task {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Version")]
    version: ObjectVersion,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "UpdatedAt")]
    updated_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Spec")]
    spec: TaskSpec,
    #[serde(rename = "ServiceID")]
    service_id: String,
    #[serde(rename = "Slot")]
    slot: i64,
    #[serde(rename = "NodeID")]
    node_id: String,
    #[serde(rename = "AssignedGenericResources")]
    assigned_generic_resources: Vec<SystemInfoGenericResources>,
    #[serde(rename = "Status")]
    status: TaskListStatus,
    #[serde(rename = "DesiredState")]
    desired_state: TaskState,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct TaskListStatus {
    #[serde(rename = "Timestamp")]
    timestamp: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "State")]
    state: TaskState,
    #[serde(rename = "Message")]
    message: String,
    #[serde(rename = "Err")]
    err: String,
    #[serde(rename = "ContainerStatus")]
    container_status: TaskListStatusContainerStatus,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct TaskListStatusContainerStatus {
    #[serde(rename = "ContainerID")]
    container_id: String,
    #[serde(rename = "PID")]
    pid: i64,
    #[serde(rename = "ExitCode")]
    exit_code: i64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct TaskSpec {
    #[serde(rename = "PluginSpec")]
    plugin_spec: ServiceListSpecTaskTemplatePluginSpec,
    #[serde(rename = "ContainerSpec")]
    container_spec: ServiceListSpecTaskTemplateContainerSpec,
    #[serde(rename = "NetworkAttachmentSpec")]
    network_attachment_spec: ServiceListSpecTaskTemplateNetworkAttachmentSpec,
    #[serde(rename = "Resources")]
    resources: ServiceListSpecTaskTemplateResources,
    #[serde(rename = "RestartPolicy")]
    restart_policy: ServiceListSpecTaskTemplateRestartPolicy,
    #[serde(rename = "Placement")]
    placement: ServiceListSpecTaskTemplatePlacement,
    #[serde(rename = "ForceUpdate")]
    force_update: i64,
    #[serde(rename = "Runtime")]
    runtime: String,
    #[serde(rename = "Networks")]
    networks: Vec<ServiceListSpecTaskTemplateNetworks>,
    #[serde(rename = "LogDriver")]
    log_driver: ServiceListSpecTaskTemplateLogDriver,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
enum TaskState {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "allocated")]
    Allocated,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "assigned")]
    Assigned,
    #[serde(rename = "accepted")]
    Accepted,
    #[serde(rename = "preparing")]
    Preparing,
    #[serde(rename = "ready")]
    Ready,
    #[serde(rename = "starting")]
    Starting,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "shutdown")]
    Shutdown,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "rejected")]
    Rejected,
    #[serde(rename = "remove")]
    Remove,
    #[serde(rename = "orphaned")]
    Orphaned,
}

impl ToString for TaskState {
    fn to_string(&self) -> String {
        match self {
            TaskState::New => "new",
            TaskState::Allocated => "allocated",
            TaskState::Pending => "pending",
            TaskState::Assigned => "assigned",
            TaskState::Accepted => "accepted",
            TaskState::Preparing => "preparing",
            TaskState::Ready => "ready",
            TaskState::Starting => "starting",
            TaskState::Running => "running",
            TaskState::Complete => "complete",
            TaskState::Shutdown => "shutdown",
            TaskState::Failed => "failed",
            TaskState::Rejected => "rejected",
            TaskState::Remove => "remove",
            TaskState::Orphaned => "orphaned",
        }.to_string()
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct ThrottleDevice {
    #[serde(rename = "Path")]
    path: String,
    #[serde(rename = "Rate")]
    rate: u64,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct Volume {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "Mountpoint")]
    mountpoint: String,
    #[serde(rename = "CreatedAt")]
    created_at: ::chrono::DateTime<::chrono::Utc>,
    #[serde(rename = "Status")]
    status: ::serde_json::Value,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
    #[serde(rename = "Scope")]
    scope: SystemDataUsageVolumesScope,
    #[serde(rename = "Options")]
    options: ::serde_json::Value,
    #[serde(rename = "UsageData")]
    usage_data: SystemDataUsageVolumesUsageData,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct VolumeCreate {
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Driver")]
    driver: String,
    #[serde(rename = "DriverOpts")]
    driver_opts: ::serde_json::Value,
    #[serde(rename = "Labels")]
    labels: ::serde_json::Value,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct VolumeList {
    #[serde(rename = "Volumes")]
    volumes: Vec<Volume>,
    #[serde(rename = "Warnings")]
    warnings: Vec<String>,
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
struct VolumePrune {
    #[serde(rename = "VolumesDeleted")]
    volumes_deleted: Vec<String>,
    #[serde(rename = "SpaceReclaimed")]
    space_reclaimed: i64,
}

#[derive(Clone, PartialEq)]
enum ContainerListCodes {
    /// no error
    Ok(Vec<ContainerList>),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_list(
    client: &Client,
    all: Option<bool>,
    limit: Option<i64>,
    size: Option<bool>,
    filters: Option<&str>,
) -> Result<ContainerListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(4);
        if let Some(all) = all {
            params.push(("all", all.to_string()));
        }
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(limit) = limit {
            params.push(("limit", limit.to_string()));
        }
        if let Some(size) = size {
            params.push(("size", size.to_string()));
        }
        Url::parse_with_params("/containers/json", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerListCodes::Ok(resp.json()?),
        400 => ContainerListCodes::BadRequest(resp.json()?),
        500 => ContainerListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerCreateCodes {
    /// Container created successfully
    Created(ContainerCreateCreated),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// conflict
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_create(
    client: &Client,
    name: Option<&str>,
    body: &ContainerCreateBody,
) -> Result<ContainerCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(name) = name {
            params.push(("name", name.to_string()));
        }
        Url::parse_with_params("/containers/create", &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ContainerCreateCodes::Created(resp.json()?),
        400 => ContainerCreateCodes::BadRequest(resp.json()?),
        404 => ContainerCreateCodes::NotFound(resp.json()?),
        409 => ContainerCreateCodes::Conflict(resp.json()?),
        500 => ContainerCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerInspectCodes {
    /// no error
    Ok(ContainerInspect),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_inspect(
    client: &Client,
    id: &str,
    size: Option<bool>,
) -> Result<ContainerInspectCodes, Error> {
    let url = format!("/containers/{id}/json",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(size) = size {
            params.push(("size", size.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerInspectCodes::Ok(resp.json()?),
        404 => ContainerInspectCodes::NotFound(resp.json()?),
        500 => ContainerInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerTopCodes {
    /// no error
    Ok(ContainerTop),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_top(
    client: &Client,
    id: &str,
    ps_args: Option<&str>,
) -> Result<ContainerTopCodes, Error> {
    let url = format!("/containers/{id}/top",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(ps_args) = ps_args {
            params.push(("ps_args", ps_args.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerTopCodes::Ok(resp.json()?),
        404 => ContainerTopCodes::NotFound(resp.json()?),
        500 => ContainerTopCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_logs(
    client: &Client,
    id: &str,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    until: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ContainerLogsCodes, Error> {
    let url = format!("/containers/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        if let Some(until) = until {
            params.push(("until", until.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerLogsCodes::SwitchingProtocols(resp.json()?),
        200 => ContainerLogsCodes::Ok(resp.json()?),
        404 => ContainerLogsCodes::NotFound(resp.json()?),
        500 => ContainerLogsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerChangesCodes {
    /// The list of changes
    Ok(Vec<ContainerChanges>),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_changes(
    client: &Client,
    id: &str,
) -> Result<ContainerChangesCodes, Error> {
    let url = format!("/containers/{id}/changes",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerChangesCodes::Ok(resp.json()?),
        404 => ContainerChangesCodes::NotFound(resp.json()?),
        500 => ContainerChangesCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerExportCodes {
    /// no error
    Ok,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_export(
    client: &Client,
    id: &str,
) -> Result<ContainerExportCodes, Error> {
    let url = format!("/containers/{id}/export",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerExportCodes::Ok,
        404 => ContainerExportCodes::NotFound(resp.json()?),
        500 => ContainerExportCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerStatsCodes {
    /// no error
    Ok(::serde_json::Value),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_stats(
    client: &Client,
    id: &str,
    stream: Option<bool>,
) -> Result<ContainerStatsCodes, Error> {
    let url = format!("/containers/{id}/stats",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerStatsCodes::Ok(resp.json()?),
        404 => ContainerStatsCodes::NotFound(resp.json()?),
        500 => ContainerStatsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerResizeCodes {
    /// no error
    Ok,
    /// no such container
    NotFound(ErrorResponse),
    /// cannot resize container
    ServerError(ErrorResponse),
}

fn container_resize(
    client: &Client,
    id: &str,
    h: Option<i64>,
    w: Option<i64>,
) -> Result<ContainerResizeCodes, Error> {
    let url = format!("/containers/{id}/resize",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(h) = h {
            params.push(("h", h.to_string()));
        }
        if let Some(w) = w {
            params.push(("w", w.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerResizeCodes::Ok,
        404 => ContainerResizeCodes::NotFound(resp.json()?),
        500 => ContainerResizeCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerStartCodes {
    /// no error
    NoContent,
    /// container already started
    NotModified(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_start(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
) -> Result<ContainerStartCodes, Error> {
    let url = format!("/containers/{id}/start",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerStartCodes::NoContent,
        304 => ContainerStartCodes::NotModified(resp.json()?),
        404 => ContainerStartCodes::NotFound(resp.json()?),
        500 => ContainerStartCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerStopCodes {
    /// no error
    NoContent,
    /// container already stopped
    NotModified(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_stop(
    client: &Client,
    id: &str,
    t: Option<i64>,
) -> Result<ContainerStopCodes, Error> {
    let url = format!("/containers/{id}/stop",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerStopCodes::NoContent,
        304 => ContainerStopCodes::NotModified(resp.json()?),
        404 => ContainerStopCodes::NotFound(resp.json()?),
        500 => ContainerStopCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerRestartCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_restart(
    client: &Client,
    id: &str,
    t: Option<i64>,
) -> Result<ContainerRestartCodes, Error> {
    let url = format!("/containers/{id}/restart",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerRestartCodes::NoContent,
        404 => ContainerRestartCodes::NotFound(resp.json()?),
        500 => ContainerRestartCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerKillCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// container is not running
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_kill(
    client: &Client,
    id: &str,
    signal: Option<&str>,
) -> Result<ContainerKillCodes, Error> {
    let url = format!("/containers/{id}/kill",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(signal) = signal {
            params.push(("signal", signal.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerKillCodes::NoContent,
        404 => ContainerKillCodes::NotFound(resp.json()?),
        409 => ContainerKillCodes::Conflict(resp.json()?),
        500 => ContainerKillCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerUpdateCodes {
    /// The container has been updated.
    Ok(ContainerUpdateOk),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_update(
    client: &Client,
    id: &str,
    update: &ContainerUpdateUpdate,
) -> Result<ContainerUpdateCodes, Error> {
    let url = format!("/containers/{id}/update",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(update)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerUpdateCodes::Ok(resp.json()?),
        404 => ContainerUpdateCodes::NotFound(resp.json()?),
        500 => ContainerUpdateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerRenameCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// name already in use
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_rename(
    client: &Client,
    id: &str,
    name: &str,
) -> Result<ContainerRenameCodes, Error> {
    let url = format!("/containers/{id}/rename",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("name", name.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerRenameCodes::NoContent,
        404 => ContainerRenameCodes::NotFound(resp.json()?),
        409 => ContainerRenameCodes::Conflict(resp.json()?),
        500 => ContainerRenameCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerPauseCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_pause(
    client: &Client,
    id: &str,
) -> Result<ContainerPauseCodes, Error> {
    let url = format!("/containers/{id}/pause",
        id=id,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerPauseCodes::NoContent,
        404 => ContainerPauseCodes::NotFound(resp.json()?),
        500 => ContainerPauseCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerUnpauseCodes {
    /// no error
    NoContent,
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_unpause(
    client: &Client,
    id: &str,
) -> Result<ContainerUnpauseCodes, Error> {
    let url = format!("/containers/{id}/unpause",
        id=id,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerUnpauseCodes::NoContent,
        404 => ContainerUnpauseCodes::NotFound(resp.json()?),
        500 => ContainerUnpauseCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerAttachCodes {
    /// no error, hints proxy about hijacking
    SwitchingProtocols,
    /// no error, no upgrade header found
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_attach(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdin: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
) -> Result<ContainerAttachCodes, Error> {
    let url = format!("/containers/{id}/attach",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(6);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        if let Some(logs) = logs {
            params.push(("logs", logs.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdin) = stdin {
            params.push(("stdin", stdin.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerAttachCodes::SwitchingProtocols,
        200 => ContainerAttachCodes::Ok,
        400 => ContainerAttachCodes::BadRequest(resp.json()?),
        404 => ContainerAttachCodes::NotFound(resp.json()?),
        500 => ContainerAttachCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerAttachWebsocketCodes {
    /// no error, hints proxy about hijacking
    SwitchingProtocols,
    /// no error, no upgrade header found
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_attach_websocket(
    client: &Client,
    id: &str,
    detach_keys: Option<&str>,
    logs: Option<bool>,
    stream: Option<bool>,
    stdin: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
) -> Result<ContainerAttachWebsocketCodes, Error> {
    let url = format!("/containers/{id}/attach/ws",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(6);
        if let Some(detach_keys) = detach_keys {
            params.push(("detach_keys", detach_keys.to_string()));
        }
        if let Some(logs) = logs {
            params.push(("logs", logs.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdin) = stdin {
            params.push(("stdin", stdin.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(stream) = stream {
            params.push(("stream", stream.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ContainerAttachWebsocketCodes::SwitchingProtocols,
        200 => ContainerAttachWebsocketCodes::Ok,
        400 => ContainerAttachWebsocketCodes::BadRequest(resp.json()?),
        404 => ContainerAttachWebsocketCodes::NotFound(resp.json()?),
        500 => ContainerAttachWebsocketCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerWaitCodes {
    /// The container has exit.
    Ok(ContainerWait),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_wait(
    client: &Client,
    id: &str,
    condition: Option<&str>,
) -> Result<ContainerWaitCodes, Error> {
    let url = format!("/containers/{id}/wait",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(condition) = condition {
            params.push(("condition", condition.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerWaitCodes::Ok(resp.json()?),
        404 => ContainerWaitCodes::NotFound(resp.json()?),
        500 => ContainerWaitCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerDeleteCodes {
    /// no error
    NoContent,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// conflict
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_delete(
    client: &Client,
    id: &str,
    v: Option<bool>,
    force: Option<bool>,
    link: Option<bool>,
) -> Result<ContainerDeleteCodes, Error> {
    let url = format!("/containers/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        if let Some(link) = link {
            params.push(("link", link.to_string()));
        }
        if let Some(v) = v {
            params.push(("v", v.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ContainerDeleteCodes::NoContent,
        400 => ContainerDeleteCodes::BadRequest(resp.json()?),
        404 => ContainerDeleteCodes::NotFound(resp.json()?),
        409 => ContainerDeleteCodes::Conflict(resp.json()?),
        500 => ContainerDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerArchiveCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Container or path does not exist
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn container_archive(
    client: &Client,
    id: &str,
    path: &str,
) -> Result<ContainerArchiveCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerArchiveCodes::Ok,
        400 => ContainerArchiveCodes::BadRequest(resp.json()?),
        404 => ContainerArchiveCodes::NotFound(resp.json()?),
        500 => ContainerArchiveCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerArchiveInfoCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Container or path does not exist
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn container_archive_info(
    client: &Client,
    id: &str,
    path: &str,
) -> Result<ContainerArchiveInfoCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.head(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerArchiveInfoCodes::Ok,
        400 => ContainerArchiveInfoCodes::BadRequest(resp.json()?),
        404 => ContainerArchiveInfoCodes::NotFound(resp.json()?),
        500 => ContainerArchiveInfoCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PutContainerArchiveCodes {
    /// The content was extracted successfully
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// Permission denied, the volume or container rootfs is marked as read-only.
    Forbidden(ErrorResponse),
    /// No such container or path does not exist inside the container
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn put_container_archive(
    client: &Client,
    id: &str,
    path: &str,
    no_overwrite_dir_non_dir: Option<&str>,
    input_stream: &str,
) -> Result<PutContainerArchiveCodes, Error> {
    let url = format!("/containers/{id}/archive",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(no_overwrite_dir_non_dir) = no_overwrite_dir_non_dir {
            params.push(("no_overwrite_dir_non_dir", no_overwrite_dir_non_dir.to_string()));
        }
        params.push(("path", path.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.put(url)
        .json(input_stream)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PutContainerArchiveCodes::Ok,
        400 => PutContainerArchiveCodes::BadRequest(resp.json()?),
        403 => PutContainerArchiveCodes::Forbidden(resp.json()?),
        404 => PutContainerArchiveCodes::NotFound(resp.json()?),
        500 => PutContainerArchiveCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerPruneCodes {
    /// No error
    Ok(ContainerPrune),
    /// Server error
    ServerError(ErrorResponse),
}

fn container_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<ContainerPruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/containers/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ContainerPruneCodes::Ok(resp.json()?),
        500 => ContainerPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageListCodes {
    /// Summary image data for the images matching the query
    Ok(Vec<ImageSummary>),
    /// server error
    ServerError(ErrorResponse),
}

fn image_list(
    client: &Client,
    all: Option<bool>,
    filters: Option<&str>,
    digests: Option<bool>,
) -> Result<ImageListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(all) = all {
            params.push(("all", all.to_string()));
        }
        if let Some(digests) = digests {
            params.push(("digests", digests.to_string()));
        }
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/images/json", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageListCodes::Ok(resp.json()?),
        500 => ImageListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageBuildCodes {
    /// no error
    Ok,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn image_build(
    client: &Client,
    input_stream: (/* binary */),
    dockerfile: Option<&str>,
    t: Option<&str>,
    extrahosts: Option<&str>,
    remote: Option<&str>,
    q: Option<bool>,
    nocache: Option<bool>,
    cachefrom: Option<&str>,
    pull: Option<&str>,
    rm: Option<bool>,
    forcerm: Option<bool>,
    memory: Option<i64>,
    memswap: Option<i64>,
    cpushares: Option<i64>,
    cpusetcpus: Option<&str>,
    cpuperiod: Option<i64>,
    cpuquota: Option<i64>,
    buildargs: Option<&str>,
    shmsize: Option<i64>,
    squash: Option<bool>,
    labels: Option<&str>,
    networkmode: Option<&str>,
    content_type: Option<&ImageBuild>,
    x_registry_config: Option<&str>,
    platform: Option<&str>,
    target: Option<&str>,
) -> Result<ImageBuildCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(23);
        if let Some(buildargs) = buildargs {
            params.push(("buildargs", buildargs.to_string()));
        }
        if let Some(cachefrom) = cachefrom {
            params.push(("cachefrom", cachefrom.to_string()));
        }
        if let Some(cpuperiod) = cpuperiod {
            params.push(("cpuperiod", cpuperiod.to_string()));
        }
        if let Some(cpuquota) = cpuquota {
            params.push(("cpuquota", cpuquota.to_string()));
        }
        if let Some(cpusetcpus) = cpusetcpus {
            params.push(("cpusetcpus", cpusetcpus.to_string()));
        }
        if let Some(cpushares) = cpushares {
            params.push(("cpushares", cpushares.to_string()));
        }
        if let Some(dockerfile) = dockerfile {
            params.push(("dockerfile", dockerfile.to_string()));
        }
        if let Some(extrahosts) = extrahosts {
            params.push(("extrahosts", extrahosts.to_string()));
        }
        if let Some(forcerm) = forcerm {
            params.push(("forcerm", forcerm.to_string()));
        }
        if let Some(labels) = labels {
            params.push(("labels", labels.to_string()));
        }
        if let Some(memory) = memory {
            params.push(("memory", memory.to_string()));
        }
        if let Some(memswap) = memswap {
            params.push(("memswap", memswap.to_string()));
        }
        if let Some(networkmode) = networkmode {
            params.push(("networkmode", networkmode.to_string()));
        }
        if let Some(nocache) = nocache {
            params.push(("nocache", nocache.to_string()));
        }
        if let Some(platform) = platform {
            params.push(("platform", platform.to_string()));
        }
        if let Some(pull) = pull {
            params.push(("pull", pull.to_string()));
        }
        if let Some(q) = q {
            params.push(("q", q.to_string()));
        }
        if let Some(remote) = remote {
            params.push(("remote", remote.to_string()));
        }
        if let Some(rm) = rm {
            params.push(("rm", rm.to_string()));
        }
        if let Some(shmsize) = shmsize {
            params.push(("shmsize", shmsize.to_string()));
        }
        if let Some(squash) = squash {
            params.push(("squash", squash.to_string()));
        }
        if let Some(t) = t {
            params.push(("t", t.to_string()));
        }
        if let Some(target) = target {
            params.push(("target", target.to_string()));
        }
        Url::parse_with_params("/build", &params)?
    };

    let mut headers = Headers::new();
    if let Some(content_type) = content_type {
        headers.set_raw("Content-type", content_type.to_string());
    }
    if let Some(x_registry_config) = x_registry_config {
        headers.set_raw("X-Registry-Config", x_registry_config.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageBuildCodes::Ok,
        400 => ImageBuildCodes::BadRequest(resp.json()?),
        500 => ImageBuildCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum BuildPruneCodes {
    /// No error
    Ok(BuildPrune),
    /// Server error
    ServerError(ErrorResponse),
}

fn build_prune(
    client: &Client,
) -> Result<BuildPruneCodes, Error> {
    let mut resp = client.post("/build/prune")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => BuildPruneCodes::Ok(resp.json()?),
        500 => BuildPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageCreateCodes {
    /// no error
    Ok,
    /// repository does not exist or no read access
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn image_create(
    client: &Client,
    from_image: Option<&str>,
    from_src: Option<&str>,
    repo: Option<&str>,
    tag: Option<&str>,
    input_image: &str,
    x_registry_auth: Option<&str>,
    platform: Option<&str>,
) -> Result<ImageCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(5);
        if let Some(from_image) = from_image {
            params.push(("from_image", from_image.to_string()));
        }
        if let Some(from_src) = from_src {
            params.push(("from_src", from_src.to_string()));
        }
        if let Some(platform) = platform {
            params.push(("platform", platform.to_string()));
        }
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params("/images/create", &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(input_image)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageCreateCodes::Ok,
        404 => ImageCreateCodes::NotFound(resp.json()?),
        500 => ImageCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageInspectCodes {
    /// No error
    Ok(Image),
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_inspect(
    client: &Client,
    name: &str,
) -> Result<ImageInspectCodes, Error> {
    let url = format!("/images/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageInspectCodes::Ok(resp.json()?),
        404 => ImageInspectCodes::NotFound(resp.json()?),
        500 => ImageInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageHistoryCodes {
    /// List of image layers
    Ok(Vec<ImageHistory>),
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_history(
    client: &Client,
    name: &str,
) -> Result<ImageHistoryCodes, Error> {
    let url = format!("/images/{name}/history",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageHistoryCodes::Ok(resp.json()?),
        404 => ImageHistoryCodes::NotFound(resp.json()?),
        500 => ImageHistoryCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImagePushCodes {
    /// No error
    Ok,
    /// No such image
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_push(
    client: &Client,
    name: &str,
    tag: Option<&str>,
    x_registry_auth: &str,
) -> Result<ImagePushCodes, Error> {
    let url = format!("/images/{name}/push",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());

    let mut resp = client.post(url)
        .headers(headers)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImagePushCodes::Ok,
        404 => ImagePushCodes::NotFound(resp.json()?),
        500 => ImagePushCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageTagCodes {
    /// No error
    Created,
    /// Bad parameter
    BadRequest(ErrorResponse),
    /// No such image
    NotFound(ErrorResponse),
    /// Conflict
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_tag(
    client: &Client,
    name: &str,
    repo: Option<&str>,
    tag: Option<&str>,
) -> Result<ImageTagCodes, Error> {
    let url = format!("/images/{name}/tag",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ImageTagCodes::Created,
        400 => ImageTagCodes::BadRequest(resp.json()?),
        404 => ImageTagCodes::NotFound(resp.json()?),
        409 => ImageTagCodes::Conflict(resp.json()?),
        500 => ImageTagCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageDeleteCodes {
    /// The image was deleted successfully
    Ok(Vec<ImageDeleteResponseItem>),
    /// No such image
    NotFound(ErrorResponse),
    /// Conflict
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
    noprune: Option<bool>,
) -> Result<ImageDeleteCodes, Error> {
    let url = format!("/images/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        if let Some(noprune) = noprune {
            params.push(("noprune", noprune.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageDeleteCodes::Ok(resp.json()?),
        404 => ImageDeleteCodes::NotFound(resp.json()?),
        409 => ImageDeleteCodes::Conflict(resp.json()?),
        500 => ImageDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageSearchCodes {
    /// No error
    Ok(Vec<ImageSearch>),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_search(
    client: &Client,
    term: &str,
    limit: Option<i64>,
    filters: Option<&str>,
) -> Result<ImageSearchCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(limit) = limit {
            params.push(("limit", limit.to_string()));
        }
        params.push(("term", term.to_string()));
        Url::parse_with_params("/images/search", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageSearchCodes::Ok(resp.json()?),
        500 => ImageSearchCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImagePruneCodes {
    /// No error
    Ok(ImagePrune),
    /// Server error
    ServerError(ErrorResponse),
}

fn image_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<ImagePruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/images/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImagePruneCodes::Ok(resp.json()?),
        500 => ImagePruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemAuthCodes {
    /// An identity token was generated successfully.
    Ok(SystemAuth),
    /// No error
    NoContent,
    /// Server error
    ServerError(ErrorResponse),
}

fn system_auth(
    client: &Client,
    auth_config: &AuthConfig,
) -> Result<SystemAuthCodes, Error> {
    let mut resp = client.post("/auth")
        .json(auth_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemAuthCodes::Ok(resp.json()?),
        204 => SystemAuthCodes::NoContent,
        500 => SystemAuthCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemInfoCodes {
    /// No error
    Ok(SystemInfo),
    /// Server error
    ServerError(ErrorResponse),
}

fn system_info(
    client: &Client,
) -> Result<SystemInfoCodes, Error> {
    let mut resp = client.get("/info")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemInfoCodes::Ok(resp.json()?),
        500 => SystemInfoCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemVersionCodes {
    /// no error
    Ok(SystemVersion),
    /// server error
    ServerError(ErrorResponse),
}

fn system_version(
    client: &Client,
) -> Result<SystemVersionCodes, Error> {
    let mut resp = client.get("/version")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemVersionCodes::Ok(resp.json()?),
        500 => SystemVersionCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemPingCodes {
    /// no error
    Ok(String),
    /// server error
    ServerError(ErrorResponse),
}

fn system_ping(
    client: &Client,
) -> Result<SystemPingCodes, Error> {
    let mut resp = client.get("/_ping")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemPingCodes::Ok(resp.json()?),
        500 => SystemPingCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageCommitCodes {
    /// no error
    Created(IdResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn image_commit(
    client: &Client,
    container_config: &ContainerConfig,
    container: Option<&str>,
    repo: Option<&str>,
    tag: Option<&str>,
    comment: Option<&str>,
    author: Option<&str>,
    pause: Option<bool>,
    changes: Option<&str>,
) -> Result<ImageCommitCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(author) = author {
            params.push(("author", author.to_string()));
        }
        if let Some(changes) = changes {
            params.push(("changes", changes.to_string()));
        }
        if let Some(comment) = comment {
            params.push(("comment", comment.to_string()));
        }
        if let Some(container) = container {
            params.push(("container", container.to_string()));
        }
        if let Some(pause) = pause {
            params.push(("pause", pause.to_string()));
        }
        if let Some(repo) = repo {
            params.push(("repo", repo.to_string()));
        }
        if let Some(tag) = tag {
            params.push(("tag", tag.to_string()));
        }
        Url::parse_with_params("/commit", &params)?
    };

    let mut resp = client.post(url)
        .json(container_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ImageCommitCodes::Created(resp.json()?),
        404 => ImageCommitCodes::NotFound(resp.json()?),
        500 => ImageCommitCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemEventsCodes {
    /// no error
    Ok(SystemEvents),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn system_events(
    client: &Client,
    since: Option<&str>,
    until: Option<&str>,
    filters: Option<&str>,
) -> Result<SystemEventsCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(until) = until {
            params.push(("until", until.to_string()));
        }
        Url::parse_with_params("/events", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemEventsCodes::Ok(resp.json()?),
        400 => SystemEventsCodes::BadRequest(resp.json()?),
        500 => SystemEventsCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SystemDataUsageCodes {
    /// no error
    Ok(SystemDataUsage),
    /// server error
    ServerError(ErrorResponse),
}

fn system_data_usage(
    client: &Client,
) -> Result<SystemDataUsageCodes, Error> {
    let mut resp = client.get("/system/df")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SystemDataUsageCodes::Ok(resp.json()?),
        500 => SystemDataUsageCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageGetCodes {
    /// no error
    Ok((/* binary */)),
    /// server error
    ServerError(ErrorResponse),
}

fn image_get(
    client: &Client,
    name: &str,
) -> Result<ImageGetCodes, Error> {
    let url = format!("/images/{name}/get",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageGetCodes::Ok(resp.json()?),
        500 => ImageGetCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageGetAllCodes {
    /// no error
    Ok((/* binary */)),
    /// server error
    ServerError(ErrorResponse),
}

fn image_get_all(
    client: &Client,
    names: Option<&[String]>,
) -> Result<ImageGetAllCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(names) = names {
            params.push(("names", names.to_vec().join(",")));
        }
        Url::parse_with_params("/images/get", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageGetAllCodes::Ok(resp.json()?),
        500 => ImageGetAllCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ImageLoadCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
}

fn image_load(
    client: &Client,
    images_tarball: (/* binary */),
    quiet: Option<bool>,
) -> Result<ImageLoadCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(quiet) = quiet {
            params.push(("quiet", quiet.to_string()));
        }
        Url::parse_with_params("/images/load", &params)?
    };

    let mut resp = client.post(url)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ImageLoadCodes::Ok,
        500 => ImageLoadCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ContainerExecCodes {
    /// no error
    Created(IdResponse),
    /// no such container
    NotFound(ErrorResponse),
    /// container is paused
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn container_exec(
    client: &Client,
    exec_config: &ContainerExec,
    id: &str,
) -> Result<ContainerExecCodes, Error> {
    let url = format!("/containers/{id}/exec",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(exec_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ContainerExecCodes::Created(resp.json()?),
        404 => ContainerExecCodes::NotFound(resp.json()?),
        409 => ContainerExecCodes::Conflict(resp.json()?),
        500 => ContainerExecCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ExecStartCodes {
    /// No error
    Ok,
    /// No such exec instance
    NotFound(ErrorResponse),
    /// Container is stopped or paused
    Conflict(ErrorResponse),
}

fn exec_start(
    client: &Client,
    exec_start_config: &ExecStart,
    id: &str,
) -> Result<ExecStartCodes, Error> {
    let url = format!("/exec/{id}/start",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(exec_start_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ExecStartCodes::Ok,
        404 => ExecStartCodes::NotFound(resp.json()?),
        409 => ExecStartCodes::Conflict(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ExecResizeCodes {
    /// No error
    Created,
    /// No such exec instance
    NotFound(ErrorResponse),
}

fn exec_resize(
    client: &Client,
    id: &str,
    h: Option<i64>,
    w: Option<i64>,
) -> Result<ExecResizeCodes, Error> {
    let url = format!("/exec/{id}/resize",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(h) = h {
            params.push(("h", h.to_string()));
        }
        if let Some(w) = w {
            params.push(("w", w.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ExecResizeCodes::Created,
        404 => ExecResizeCodes::NotFound(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ExecInspectCodes {
    /// No error
    Ok(ExecInspect),
    /// No such exec instance
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn exec_inspect(
    client: &Client,
    id: &str,
) -> Result<ExecInspectCodes, Error> {
    let url = format!("/exec/{id}/json",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ExecInspectCodes::Ok(resp.json()?),
        404 => ExecInspectCodes::NotFound(resp.json()?),
        500 => ExecInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum VolumeListCodes {
    /// Summary volume data that matches the query
    Ok(VolumeList),
    /// Server error
    ServerError(ErrorResponse),
}

fn volume_list(
    client: &Client,
    filters: Option<::serde_json::Value>,
) -> Result<VolumeListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/volumes", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumeListCodes::Ok(resp.json()?),
        500 => VolumeListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum VolumeCreateCodes {
    /// The volume was created successfully
    Created(Volume),
    /// Server error
    ServerError(ErrorResponse),
}

fn volume_create(
    client: &Client,
    volume_config: &VolumeCreate,
) -> Result<VolumeCreateCodes, Error> {
    let mut resp = client.post("/volumes/create")
        .json(volume_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => VolumeCreateCodes::Created(resp.json()?),
        500 => VolumeCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum VolumeInspectCodes {
    /// No error
    Ok(Volume),
    /// No such volume
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn volume_inspect(
    client: &Client,
    name: &str,
) -> Result<VolumeInspectCodes, Error> {
    let url = format!("/volumes/{name}",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumeInspectCodes::Ok(resp.json()?),
        404 => VolumeInspectCodes::NotFound(resp.json()?),
        500 => VolumeInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum VolumeDeleteCodes {
    /// The volume was removed
    NoContent,
    /// No such volume or volume driver
    NotFound(ErrorResponse),
    /// Volume is in use and cannot be removed
    Conflict(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn volume_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
) -> Result<VolumeDeleteCodes, Error> {
    let url = format!("/volumes/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => VolumeDeleteCodes::NoContent,
        404 => VolumeDeleteCodes::NotFound(resp.json()?),
        409 => VolumeDeleteCodes::Conflict(resp.json()?),
        500 => VolumeDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum VolumePruneCodes {
    /// No error
    Ok(VolumePrune),
    /// Server error
    ServerError(ErrorResponse),
}

fn volume_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<VolumePruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/volumes/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => VolumePruneCodes::Ok(resp.json()?),
        500 => VolumePruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkListCodes {
    /// No error
    Ok(Vec<Network>),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<NetworkListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/networks", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkListCodes::Ok(resp.json()?),
        500 => NetworkListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkInspectCodes {
    /// No error
    Ok(Network),
    /// Network not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_inspect(
    client: &Client,
    id: &str,
    verbose: Option<bool>,
    scope: Option<&str>,
) -> Result<NetworkInspectCodes, Error> {
    let url = format!("/networks/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(scope) = scope {
            params.push(("scope", scope.to_string()));
        }
        if let Some(verbose) = verbose {
            params.push(("verbose", verbose.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkInspectCodes::Ok(resp.json()?),
        404 => NetworkInspectCodes::NotFound(resp.json()?),
        500 => NetworkInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkDeleteCodes {
    /// No error
    NoContent,
    /// operation not supported for pre-defined networks
    Forbidden(ErrorResponse),
    /// no such network
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_delete(
    client: &Client,
    id: &str,
) -> Result<NetworkDeleteCodes, Error> {
    let url = format!("/networks/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => NetworkDeleteCodes::NoContent,
        403 => NetworkDeleteCodes::Forbidden(resp.json()?),
        404 => NetworkDeleteCodes::NotFound(resp.json()?),
        500 => NetworkDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkCreateCodes {
    /// No error
    Created(NetworkCreateCreated),
    /// operation not supported for pre-defined networks
    Forbidden(ErrorResponse),
    /// plugin not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_create(
    client: &Client,
    network_config: &NetworkCreateNetworkConfig,
) -> Result<NetworkCreateCodes, Error> {
    let mut resp = client.post("/networks/create")
        .json(network_config)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => NetworkCreateCodes::Created(resp.json()?),
        403 => NetworkCreateCodes::Forbidden(resp.json()?),
        404 => NetworkCreateCodes::NotFound(resp.json()?),
        500 => NetworkCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkConnectCodes {
    /// No error
    Ok,
    /// Operation not supported for swarm scoped networks
    Forbidden(ErrorResponse),
    /// Network or container not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_connect(
    client: &Client,
    id: &str,
    container: &NetworkConnect,
) -> Result<NetworkConnectCodes, Error> {
    let url = format!("/networks/{id}/connect",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(container)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkConnectCodes::Ok,
        403 => NetworkConnectCodes::Forbidden(resp.json()?),
        404 => NetworkConnectCodes::NotFound(resp.json()?),
        500 => NetworkConnectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkDisconnectCodes {
    /// No error
    Ok,
    /// Operation not supported for swarm scoped networks
    Forbidden(ErrorResponse),
    /// Network or container not found
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_disconnect(
    client: &Client,
    id: &str,
    container: &NetworkDisconnect,
) -> Result<NetworkDisconnectCodes, Error> {
    let url = format!("/networks/{id}/disconnect",
        id=id,
    );

    let mut resp = client.post(&url)
        .json(container)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkDisconnectCodes::Ok,
        403 => NetworkDisconnectCodes::Forbidden(resp.json()?),
        404 => NetworkDisconnectCodes::NotFound(resp.json()?),
        500 => NetworkDisconnectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NetworkPruneCodes {
    /// No error
    Ok(NetworkPrune),
    /// Server error
    ServerError(ErrorResponse),
}

fn network_prune(
    client: &Client,
    filters: Option<&str>,
) -> Result<NetworkPruneCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/networks/prune", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NetworkPruneCodes::Ok(resp.json()?),
        500 => NetworkPruneCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginListCodes {
    /// No error
    Ok(Vec<Plugin>),
    /// Server error
    ServerError(ErrorResponse),
}

fn plugin_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<PluginListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/plugins", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginListCodes::Ok(resp.json()?),
        500 => PluginListCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum GetPluginPrivilegesCodes {
    /// no error
    Ok(Vec<GetPluginPrivileges>),
    /// server error
    ServerError(ErrorResponse),
}

fn get_plugin_privileges(
    client: &Client,
    remote: &str,
) -> Result<GetPluginPrivilegesCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("remote", remote.to_string()));
        Url::parse_with_params("/plugins/privileges", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => GetPluginPrivilegesCodes::Ok(resp.json()?),
        500 => GetPluginPrivilegesCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginPullCodes {
    /// no error
    NoContent,
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_pull(
    client: &Client,
    remote: &str,
    name: Option<&str>,
    x_registry_auth: Option<&str>,
    body: &[GetPluginPrivileges],
) -> Result<PluginPullCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(2);
        if let Some(name) = name {
            params.push(("name", name.to_string()));
        }
        params.push(("remote", remote.to_string()));
        Url::parse_with_params("/plugins/pull", &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginPullCodes::NoContent,
        500 => PluginPullCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginInspectCodes {
    /// no error
    Ok(Plugin),
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_inspect(
    client: &Client,
    name: &str,
) -> Result<PluginInspectCodes, Error> {
    let url = format!("/plugins/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginInspectCodes::Ok(resp.json()?),
        404 => PluginInspectCodes::NotFound(resp.json()?),
        500 => PluginInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginDeleteCodes {
    /// no error
    Ok(Plugin),
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_delete(
    client: &Client,
    name: &str,
    force: Option<bool>,
) -> Result<PluginDeleteCodes, Error> {
    let url = format!("/plugins/{name}",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginDeleteCodes::Ok(resp.json()?),
        404 => PluginDeleteCodes::NotFound(resp.json()?),
        500 => PluginDeleteCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginEnableCodes {
    /// no error
    Ok,
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_enable(
    client: &Client,
    name: &str,
    timeout: Option<i64>,
) -> Result<PluginEnableCodes, Error> {
    let url = format!("/plugins/{name}/enable",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(timeout) = timeout {
            params.push(("timeout", timeout.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginEnableCodes::Ok,
        404 => PluginEnableCodes::NotFound(resp.json()?),
        500 => PluginEnableCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginDisableCodes {
    /// no error
    Ok,
    /// plugin is not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_disable(
    client: &Client,
    name: &str,
) -> Result<PluginDisableCodes, Error> {
    let url = format!("/plugins/{name}/disable",
        name=name,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginDisableCodes::Ok,
        404 => PluginDisableCodes::NotFound(resp.json()?),
        500 => PluginDisableCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginUpgradeCodes {
    /// no error
    NoContent,
    /// plugin not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_upgrade(
    client: &Client,
    name: &str,
    remote: &str,
    x_registry_auth: Option<&str>,
    body: &[GetPluginPrivileges],
) -> Result<PluginUpgradeCodes, Error> {
    let url = format!("/plugins/{name}/upgrade",
        name=name,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("remote", remote.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginUpgradeCodes::NoContent,
        404 => PluginUpgradeCodes::NotFound(resp.json()?),
        500 => PluginUpgradeCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginCreateCodes {
    /// no error
    NoContent,
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_create(
    client: &Client,
    name: &str,
    tar_context: (/* binary */),
) -> Result<PluginCreateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("name", name.to_string()));
        Url::parse_with_params("/plugins/create", &params)?
    };

    let mut resp = client.post(url)
        // TODO: unknown body type
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginCreateCodes::NoContent,
        500 => PluginCreateCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginPushCodes {
    /// no error
    Ok,
    /// plugin not installed
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn plugin_push(
    client: &Client,
    name: &str,
) -> Result<PluginPushCodes, Error> {
    let url = format!("/plugins/{name}/push",
        name=name,
    );

    let mut resp = client.post(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => PluginPushCodes::Ok,
        404 => PluginPushCodes::NotFound(resp.json()?),
        500 => PluginPushCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum PluginSetCodes {
    /// No error
    NoContent,
    /// Plugin not installed
    NotFound(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn plugin_set(
    client: &Client,
    name: &str,
    body: &[String],
) -> Result<PluginSetCodes, Error> {
    let url = format!("/plugins/{name}/set",
        name=name,
    );

    let mut resp = client.post(&url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => PluginSetCodes::NoContent,
        404 => PluginSetCodes::NotFound(resp.json()?),
        500 => PluginSetCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NodeListCodes {
    /// no error
    Ok(Vec<Node>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn node_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<NodeListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/nodes", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeListCodes::Ok(resp.json()?),
        500 => NodeListCodes::ServerError(resp.json()?),
        503 => NodeListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NodeInspectCodes {
    /// no error
    Ok(Node),
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn node_inspect(
    client: &Client,
    id: &str,
) -> Result<NodeInspectCodes, Error> {
    let url = format!("/nodes/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeInspectCodes::Ok(resp.json()?),
        404 => NodeInspectCodes::NotFound(resp.json()?),
        500 => NodeInspectCodes::ServerError(resp.json()?),
        503 => NodeInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NodeDeleteCodes {
    /// no error
    Ok,
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn node_delete(
    client: &Client,
    id: &str,
    force: Option<bool>,
) -> Result<NodeDeleteCodes, Error> {
    let url = format!("/nodes/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.delete(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeDeleteCodes::Ok,
        404 => NodeDeleteCodes::NotFound(resp.json()?),
        500 => NodeDeleteCodes::ServerError(resp.json()?),
        503 => NodeDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum NodeUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such node
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn node_update(
    client: &Client,
    id: &str,
    body: &NodeSpec,
    version: i64,
) -> Result<NodeUpdateCodes, Error> {
    let url = format!("/nodes/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => NodeUpdateCodes::Ok,
        400 => NodeUpdateCodes::BadRequest(resp.json()?),
        404 => NodeUpdateCodes::NotFound(resp.json()?),
        500 => NodeUpdateCodes::ServerError(resp.json()?),
        503 => NodeUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmInspectCodes {
    /// no error
    Ok(Swarm),
    /// no such swarm
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_inspect(
    client: &Client,
) -> Result<SwarmInspectCodes, Error> {
    let mut resp = client.get("/swarm")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmInspectCodes::Ok(resp.json()?),
        404 => SwarmInspectCodes::NotFound(resp.json()?),
        500 => SwarmInspectCodes::ServerError(resp.json()?),
        503 => SwarmInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmInitCodes {
    /// no error
    Ok(String),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is already part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_init(
    client: &Client,
    body: &SwarmInit,
) -> Result<SwarmInitCodes, Error> {
    let mut resp = client.post("/swarm/init")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmInitCodes::Ok(resp.json()?),
        400 => SwarmInitCodes::BadRequest(resp.json()?),
        500 => SwarmInitCodes::ServerError(resp.json()?),
        503 => SwarmInitCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmJoinCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is already part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_join(
    client: &Client,
    body: &SwarmJoin,
) -> Result<SwarmJoinCodes, Error> {
    let mut resp = client.post("/swarm/join")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmJoinCodes::Ok,
        400 => SwarmJoinCodes::BadRequest(resp.json()?),
        500 => SwarmJoinCodes::ServerError(resp.json()?),
        503 => SwarmJoinCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmLeaveCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_leave(
    client: &Client,
    force: Option<bool>,
) -> Result<SwarmLeaveCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(force) = force {
            params.push(("force", force.to_string()));
        }
        Url::parse_with_params("/swarm/leave", &params)?
    };

    let mut resp = client.post(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmLeaveCodes::Ok,
        500 => SwarmLeaveCodes::ServerError(resp.json()?),
        503 => SwarmLeaveCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_update(
    client: &Client,
    body: &SwarmSpec,
    version: i64,
    rotate_worker_token: Option<bool>,
    rotate_manager_token: Option<bool>,
    rotate_manager_unlock_key: Option<bool>,
) -> Result<SwarmUpdateCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(4);
        if let Some(rotate_manager_token) = rotate_manager_token {
            params.push(("rotate_manager_token", rotate_manager_token.to_string()));
        }
        if let Some(rotate_manager_unlock_key) = rotate_manager_unlock_key {
            params.push(("rotate_manager_unlock_key", rotate_manager_unlock_key.to_string()));
        }
        if let Some(rotate_worker_token) = rotate_worker_token {
            params.push(("rotate_worker_token", rotate_worker_token.to_string()));
        }
        params.push(("version", version.to_string()));
        Url::parse_with_params("/swarm/update", &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUpdateCodes::Ok,
        400 => SwarmUpdateCodes::BadRequest(resp.json()?),
        500 => SwarmUpdateCodes::ServerError(resp.json()?),
        503 => SwarmUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmUnlockkeyCodes {
    /// no error
    Ok(SwarmUnlockkey),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_unlockkey(
    client: &Client,
) -> Result<SwarmUnlockkeyCodes, Error> {
    let mut resp = client.get("/swarm/unlockkey")
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUnlockkeyCodes::Ok(resp.json()?),
        500 => SwarmUnlockkeyCodes::ServerError(resp.json()?),
        503 => SwarmUnlockkeyCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SwarmUnlockCodes {
    /// no error
    Ok,
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn swarm_unlock(
    client: &Client,
    body: &SwarmUnlockkey,
) -> Result<SwarmUnlockCodes, Error> {
    let mut resp = client.post("/swarm/unlock")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SwarmUnlockCodes::Ok,
        500 => SwarmUnlockCodes::ServerError(resp.json()?),
        503 => SwarmUnlockCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceListCodes {
    /// no error
    Ok(Vec<Service>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<ServiceListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/services", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceListCodes::Ok(resp.json()?),
        500 => ServiceListCodes::ServerError(resp.json()?),
        503 => ServiceListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceCreateCodes {
    /// no error
    Created(ServiceCreate),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// network is not eligible for services
    Forbidden(ErrorResponse),
    /// name conflicts with an existing service
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_create(
    client: &Client,
    body: &ServiceSpec,
    x_registry_auth: Option<&str>,
) -> Result<ServiceCreateCodes, Error> {
    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post("/services/create")
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ServiceCreateCodes::Created(resp.json()?),
        400 => ServiceCreateCodes::BadRequest(resp.json()?),
        403 => ServiceCreateCodes::Forbidden(resp.json()?),
        409 => ServiceCreateCodes::Conflict(resp.json()?),
        500 => ServiceCreateCodes::ServerError(resp.json()?),
        503 => ServiceCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceInspectCodes {
    /// no error
    Ok(Service),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_inspect(
    client: &Client,
    id: &str,
    insert_defaults: Option<bool>,
) -> Result<ServiceInspectCodes, Error> {
    let url = format!("/services/{id}",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(insert_defaults) = insert_defaults {
            params.push(("insert_defaults", insert_defaults.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceInspectCodes::Ok(resp.json()?),
        404 => ServiceInspectCodes::NotFound(resp.json()?),
        500 => ServiceInspectCodes::ServerError(resp.json()?),
        503 => ServiceInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceDeleteCodes {
    /// no error
    Ok,
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_delete(
    client: &Client,
    id: &str,
) -> Result<ServiceDeleteCodes, Error> {
    let url = format!("/services/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceDeleteCodes::Ok,
        404 => ServiceDeleteCodes::NotFound(resp.json()?),
        500 => ServiceDeleteCodes::ServerError(resp.json()?),
        503 => ServiceDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceUpdateCodes {
    /// no error
    Ok(ServiceUpdateResponse),
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_update(
    client: &Client,
    id: &str,
    body: &ServiceSpec,
    version: i64,
    registry_auth_from: Option<&str>,
    rollback: Option<&str>,
    x_registry_auth: Option<&str>,
) -> Result<ServiceUpdateCodes, Error> {
    let url = format!("/services/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(3);
        if let Some(registry_auth_from) = registry_auth_from {
            params.push(("registry_auth_from", registry_auth_from.to_string()));
        }
        if let Some(rollback) = rollback {
            params.push(("rollback", rollback.to_string()));
        }
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut headers = Headers::new();
    if let Some(x_registry_auth) = x_registry_auth {
        headers.set_raw("X-Registry-Auth", x_registry_auth.to_string());
    }

    let mut resp = client.post(url)
        .headers(headers)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ServiceUpdateCodes::Ok(resp.json()?),
        400 => ServiceUpdateCodes::BadRequest(resp.json()?),
        404 => ServiceUpdateCodes::NotFound(resp.json()?),
        500 => ServiceUpdateCodes::ServerError(resp.json()?),
        503 => ServiceUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ServiceLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such service
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn service_logs(
    client: &Client,
    id: &str,
    details: Option<bool>,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<ServiceLogsCodes, Error> {
    let url = format!("/services/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(details) = details {
            params.push(("details", details.to_string()));
        }
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => ServiceLogsCodes::SwitchingProtocols(resp.json()?),
        200 => ServiceLogsCodes::Ok(resp.json()?),
        404 => ServiceLogsCodes::NotFound(resp.json()?),
        500 => ServiceLogsCodes::ServerError(resp.json()?),
        503 => ServiceLogsCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum TaskListCodes {
    /// no error
    Ok(Vec<Task>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn task_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<TaskListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/tasks", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => TaskListCodes::Ok(resp.json()?),
        500 => TaskListCodes::ServerError(resp.json()?),
        503 => TaskListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum TaskInspectCodes {
    /// no error
    Ok(Task),
    /// no such task
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn task_inspect(
    client: &Client,
    id: &str,
) -> Result<TaskInspectCodes, Error> {
    let url = format!("/tasks/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => TaskInspectCodes::Ok(resp.json()?),
        404 => TaskInspectCodes::NotFound(resp.json()?),
        500 => TaskInspectCodes::ServerError(resp.json()?),
        503 => TaskInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum TaskLogsCodes {
    /// logs returned as a stream
    SwitchingProtocols((/* binary */)),
    /// logs returned as a string in response body
    Ok(String),
    /// no such task
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn task_logs(
    client: &Client,
    id: &str,
    details: Option<bool>,
    follow: Option<bool>,
    stdout: Option<bool>,
    stderr: Option<bool>,
    since: Option<i64>,
    timestamps: Option<bool>,
    tail: Option<&str>,
) -> Result<TaskLogsCodes, Error> {
    let url = format!("/tasks/{id}/logs",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(7);
        if let Some(details) = details {
            params.push(("details", details.to_string()));
        }
        if let Some(follow) = follow {
            params.push(("follow", follow.to_string()));
        }
        if let Some(since) = since {
            params.push(("since", since.to_string()));
        }
        if let Some(stderr) = stderr {
            params.push(("stderr", stderr.to_string()));
        }
        if let Some(stdout) = stdout {
            params.push(("stdout", stdout.to_string()));
        }
        if let Some(tail) = tail {
            params.push(("tail", tail.to_string()));
        }
        if let Some(timestamps) = timestamps {
            params.push(("timestamps", timestamps.to_string()));
        }
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => TaskLogsCodes::SwitchingProtocols(resp.json()?),
        200 => TaskLogsCodes::Ok(resp.json()?),
        404 => TaskLogsCodes::NotFound(resp.json()?),
        500 => TaskLogsCodes::ServerError(resp.json()?),
        503 => TaskLogsCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SecretListCodes {
    /// no error
    Ok(Vec<Secret>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn secret_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<SecretListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/secrets", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretListCodes::Ok(resp.json()?),
        500 => SecretListCodes::ServerError(resp.json()?),
        503 => SecretListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SecretCreateCodes {
    /// no error
    Created(IdResponse),
    /// name conflicts with an existing object
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn secret_create(
    client: &Client,
    body: &SecretSpec,
) -> Result<SecretCreateCodes, Error> {
    let mut resp = client.post("/secrets/create")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => SecretCreateCodes::Created(resp.json()?),
        409 => SecretCreateCodes::Conflict(resp.json()?),
        500 => SecretCreateCodes::ServerError(resp.json()?),
        503 => SecretCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SecretInspectCodes {
    /// no error
    Ok(Secret),
    /// secret not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn secret_inspect(
    client: &Client,
    id: &str,
) -> Result<SecretInspectCodes, Error> {
    let url = format!("/secrets/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretInspectCodes::Ok(resp.json()?),
        404 => SecretInspectCodes::NotFound(resp.json()?),
        500 => SecretInspectCodes::ServerError(resp.json()?),
        503 => SecretInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SecretDeleteCodes {
    /// no error
    NoContent,
    /// secret not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn secret_delete(
    client: &Client,
    id: &str,
) -> Result<SecretDeleteCodes, Error> {
    let url = format!("/secrets/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => SecretDeleteCodes::NoContent,
        404 => SecretDeleteCodes::NotFound(resp.json()?),
        500 => SecretDeleteCodes::ServerError(resp.json()?),
        503 => SecretDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SecretUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such secret
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn secret_update(
    client: &Client,
    id: &str,
    body: &SecretSpec,
    version: i64,
) -> Result<SecretUpdateCodes, Error> {
    let url = format!("/secrets/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => SecretUpdateCodes::Ok,
        400 => SecretUpdateCodes::BadRequest(resp.json()?),
        404 => SecretUpdateCodes::NotFound(resp.json()?),
        500 => SecretUpdateCodes::ServerError(resp.json()?),
        503 => SecretUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ConfigListCodes {
    /// no error
    Ok(Vec<Config>),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn config_list(
    client: &Client,
    filters: Option<&str>,
) -> Result<ConfigListCodes, Error> {
    let url = {
        let mut params = Vec::with_capacity(1);
        if let Some(filters) = filters {
            params.push(("filters", filters.to_string()));
        }
        Url::parse_with_params("/configs", &params)?
    };

    let mut resp = client.get(url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigListCodes::Ok(resp.json()?),
        500 => ConfigListCodes::ServerError(resp.json()?),
        503 => ConfigListCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ConfigCreateCodes {
    /// no error
    Created(IdResponse),
    /// name conflicts with an existing object
    Conflict(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn config_create(
    client: &Client,
    body: &ConfigSpec,
) -> Result<ConfigCreateCodes, Error> {
    let mut resp = client.post("/configs/create")
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        201 => ConfigCreateCodes::Created(resp.json()?),
        409 => ConfigCreateCodes::Conflict(resp.json()?),
        500 => ConfigCreateCodes::ServerError(resp.json()?),
        503 => ConfigCreateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ConfigInspectCodes {
    /// no error
    Ok(Config),
    /// config not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn config_inspect(
    client: &Client,
    id: &str,
) -> Result<ConfigInspectCodes, Error> {
    let url = format!("/configs/{id}",
        id=id,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigInspectCodes::Ok(resp.json()?),
        404 => ConfigInspectCodes::NotFound(resp.json()?),
        500 => ConfigInspectCodes::ServerError(resp.json()?),
        503 => ConfigInspectCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ConfigDeleteCodes {
    /// no error
    NoContent,
    /// config not found
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn config_delete(
    client: &Client,
    id: &str,
) -> Result<ConfigDeleteCodes, Error> {
    let url = format!("/configs/{id}",
        id=id,
    );

    let mut resp = client.delete(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        204 => ConfigDeleteCodes::NoContent,
        404 => ConfigDeleteCodes::NotFound(resp.json()?),
        500 => ConfigDeleteCodes::ServerError(resp.json()?),
        503 => ConfigDeleteCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum ConfigUpdateCodes {
    /// no error
    Ok,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// no such config
    NotFound(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
    /// node is not part of a swarm
    ServiceUnavailable(ErrorResponse),
}

fn config_update(
    client: &Client,
    id: &str,
    body: &ConfigSpec,
    version: i64,
) -> Result<ConfigUpdateCodes, Error> {
    let url = format!("/configs/{id}/update",
        id=id,
    );

    let url = {
        let mut params = Vec::with_capacity(1);
        params.push(("version", version.to_string()));
        Url::parse_with_params(&url, &params)?
    };

    let mut resp = client.post(url)
        .json(body)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => ConfigUpdateCodes::Ok,
        400 => ConfigUpdateCodes::BadRequest(resp.json()?),
        404 => ConfigUpdateCodes::NotFound(resp.json()?),
        500 => ConfigUpdateCodes::ServerError(resp.json()?),
        503 => ConfigUpdateCodes::ServiceUnavailable(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum DistributionInspectCodes {
    /// descriptor and platform information
    Ok(DistributionInspect),
    /// Failed authentication or no image found
    Unauthorised(ErrorResponse),
    /// Server error
    ServerError(ErrorResponse),
}

fn distribution_inspect(
    client: &Client,
    name: &str,
) -> Result<DistributionInspectCodes, Error> {
    let url = format!("/distribution/{name}/json",
        name=name,
    );

    let mut resp = client.get(&url)
        .send()?;

    Ok(match resp.status().as_u16() {
        200 => DistributionInspectCodes::Ok(resp.json()?),
        401 => DistributionInspectCodes::Unauthorised(resp.json()?),
        500 => DistributionInspectCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

#[derive(Clone, PartialEq)]
enum SessionCodes {
    /// no error, hijacking successful
    SwitchingProtocols,
    /// bad parameter
    BadRequest(ErrorResponse),
    /// server error
    ServerError(ErrorResponse),
}

fn session(
    client: &Client,
) -> Result<SessionCodes, Error> {
    let mut resp = client.post("/session")
        .send()?;

    Ok(match resp.status().as_u16() {
        101 => SessionCodes::SwitchingProtocols,
        400 => SessionCodes::BadRequest(resp.json()?),
        500 => SessionCodes::ServerError(resp.json()?),
        other => bail!("unexpected server response {}", other),
    })
}

